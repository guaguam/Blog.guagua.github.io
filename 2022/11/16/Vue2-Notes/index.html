<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue2 Notes | GuaGua's BLOG</title><meta name="author" content="GuaGuaSuaka"><meta name="copyright" content="GuaGuaSuaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Vue 介绍什么是 vue ？构建用户界面用 vue 往 html 页面中填充数据，非常的方便框架框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！要学习 vue，就是在学习 vue 框架中规定的用法！vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库只有把上面老师罗列的内容掌握以后，才有开发 vue 项目的能力！vue 的两个特性数据驱动视图：">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue2 Notes">
<meta property="og:url" content="https://www.guaguablog.online/2022/11/16/Vue2-Notes/index.html">
<meta property="og:site_name" content="GuaGua&#39;s BLOG">
<meta property="og:description" content="Vue 介绍什么是 vue ？构建用户界面用 vue 往 html 页面中填充数据，非常的方便框架框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！要学习 vue，就是在学习 vue 框架中规定的用法！vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库只有把上面老师罗列的内容掌握以后，才有开发 vue 项目的能力！vue 的两个特性数据驱动视图：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.guaguablog.online/images/vue.jpeg">
<meta property="article:published_time" content="2022-11-16T13:16:37.000Z">
<meta property="article:modified_time" content="2022-11-16T13:55:54.428Z">
<meta property="article:author" content="GuaGuaSuaka">
<meta property="article:tag" content="BLOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.guaguablog.online/images/vue.jpeg"><link rel="shortcut icon" href="/images/1.jpeg"><link rel="canonical" href="https://www.guaguablog.online/2022/11/16/Vue2-Notes/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue2 Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-11-16 21:55:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/vue.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GuaGua's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue2 Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-16T13:16:37.000Z" title="发表于 2022-11-16 21:16:37">2022-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-16T13:55:54.428Z" title="更新于 2022-11-16 21:55:54">2022-11-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue2 Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Vue 介绍<br>什么是 vue ？<br>构建用户界面<br>用 vue 往 html 页面中填充数据，非常的方便<br>框架<br>框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！<br>要学习 vue，就是在学习 vue 框架中规定的用法！<br>vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库<br>只有把上面老师罗列的内容掌握以后，才有开发 vue 项目的能力！<br>vue 的两个特性<br>数据驱动视图：</p>
<p>数据的变化会驱动视图自动更新<br>好处：程序员只管把数据维护好，那么页面结构会被 vue 自动渲染出来！<br>双向数据绑定：</p>
<p>在网页中，form 表单负责采集数据，Ajax 负责提交数据。</p>
<p>js 数据的变化，会被自动渲染到页面上<br>页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中<br>注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Mode 数据源、View 视图、ViewModel 就是 vue 的实例）</p>
<p>MVVM<br>MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。</p>
<p>MVVM 的工作原理<br>ViewModel作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。</p>
<p>当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构。</p>
<p>当单元素的值发生变化表时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中</p>
<p>起步<br>第一个Vue程序：</p>
<p>导入开发版本的 Vue.js</p>
<p>创建 Vue实例对象，设置el属性和data属性</p>
<p>使用简洁的模板语法把数据渲染到页面上</p>
<p> 双{message}双<br>基本代码与 MVVM 的对应关系</p>
<p>插件库<br>day.js 快速日期格式化</p>
<p>解决格式化Vue文件时 逗号、分号问题 ：</p>
<p>在根目录中，添加一个 .prettierrc.json 配置文件，写入：</p>
<p>{<br>    “singleQuote”: true,<br>    “semi”: false,<br>    “trailingComma”: “none”<br>}<br>一劳永逸方法：</p>
<p>在电脑上的用户目录下新建一个 .prettierrc.json 文件，同理上面的参数。</p>
<p>在 **Vs code **的 setting.json 中添加配置路径：</p>
<pre><code> 设置 配置文件,解决格式化vue文件时逗号、分号爆红问题
 这里注意配置路径，记得使自己计算机上的用户名
</code></pre>
<p>  “prettier.configPath”: “C:/Users/mi/.prettierrc.json”,<br>解决格式化时函数括号前的空格问题 ：</p>
<p>Prettier 格式化插件无法处理函数括号前添加空格问题<br>解决办法一、在当前项目里的 .eslintrc.js 里 rules 规则里添加忽略加空格爆红提示 ：<br>‘space-before-function-paren’:[‘error’,’never’]<br>解决办法二： 使用 Prettier now 插件可以解决此问题。<br>vue 指令</p>
<ol>
<li><p>内容渲染指令<br>v-text 设置标签的内容, 默认写法会 覆盖元素内部原有的内容 , 内部支持写表达式。<br>双{ }双 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！<br>v-html 指令的作用：可以把带有标签的字符串，渲染成真正的 HTML 内容！<br>注意：插值表达式只能用在元素的内容节点中，不能用在元素的属性节点中！</p>
</li>
<li><p>v-bind 属性绑定属性<br>在 vue 中，可以使用 v-bind: 指令，为元素的属性动态绑定值；<br>简写是英文的 :<br>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p>
</li>
</ol>
<p>div :title=”‘box’ + index”这是一个 div/div<br>使用 v-bind 在元素绑定时希望内传入 Number数值时，避免被解析成字符串</p>
<p>select    v-model=’value’<br>    option  ：value=’数字’…/option<br>/select<br>3. v-on 事件绑定属性<br>v-on: 简写是 @</p>
<p>语法格式为：</p>
<p>p count的值是： 双{ count }双/p</p>
<p>button @click=”add”/button</p>
<p>methods: {<br>   add() {<br>             如果在方法中要修改 data 中的数据，可以通过 this 访问到<br>            this.count += 1<br>   }<br>}<br>$event<br>在事件绑定时，会有一个原生DOM 的事件对象 e，如果事件对象传入参数，默认的事件对象会被覆盖。</p>
<p>$event 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个 $event。</p>
<p>例如：</p>
<p> 点击按钮让count值 递增，绑定点击事件并传参</p>
<p>button @click=”add(3, $event)”/button</p>
<p>methods: {<br>   add(n, e) {<br>             如果在方法中要修改 data 中的数据，可以通过 this 访问到<br>            this.count += 1<br>   }<br>}<br>事件修饰符：<br>事件绑定期间非常好玩的一个东西，对事件的触发进行控制。</p>
<p>.prevent</p>
<p>a @click.prevent=”xxx”链接/a<br>1<br>.stop</p>
<p>button @click.stop=”xxx”按钮/button<br>1<br>事件修饰符</p>
<p>说明</p>
<p>.prevent</p>
<p>阻止默认行为 (如：阻止a链接的跳转，阻止表单提交等)</p>
<p>.stop</p>
<p>阻止冒泡事件</p>
<p>.capture</p>
<p>以捕获模式触发当前的事件处理函数</p>
<p>.once</p>
<p>绑定的事件只触发一次</p>
<p>.self</p>
<p>只有在event.target 是当前元素自身时触发事件处理函数</p>
<p>按键修饰符<br>按键</p>
<p>键码值</p>
<p>使用</p>
<p>Enter</p>
<p>13</p>
<p>.enter</p>
<p>Tab</p>
<p>9</p>
<p>.tab</p>
<p>Delete</p>
<p>46</p>
<p>.delete (捕获“删除”和“退格”按键)</p>
<p>Esc</p>
<p>27</p>
<p>.esc</p>
<p>BackSpace</p>
<p>8</p>
<p>.space</p>
<p>Up Arrow</p>
<p>38</p>
<p>.up</p>
<p>Left Arrow</p>
<p>37</p>
<p>.left</p>
<p>Right Arrow</p>
<p>39</p>
<p>.right</p>
<p>Dw Arrow</p>
<p>40</p>
<p>.down</p>
<p>1.自定义其他的按键别名：</p>
<p>Vue.config.keyCodes.f6 = 118</p>
<p>input @keyup.f6=”xxx” /   只有单击f6键才会触发xxx的回调<br>2.多个按键一并触发该事件</p>
<p>@keyup.ctrl.enter=”XXX”     按下ctrl和enter才触发事件执行<br>【案例应用】：表单输入后按回车键添,按esc则清空表单</p>
<p>input type=”text” v-model=”newbrand”<br>       @keyup.enter=”add”<br>       @keyup.esc=”newbrand=’’” /<br>4. v-model 表单绑定<br>在不操作 DOM 的前提下，实现表单元素和数据的双向绑定。</p>
<p>v-model 指令的修饰符</p>
<p>修饰符</p>
<p>作用</p>
<p>示例</p>
<p>.number</p>
<p>自动将用户输入值转为 Number</p>
<p>input v-model.number=“age” /</p>
<p>.trim</p>
<p>去除首尾空白字符</p>
<p>input v-model.trim=“msg” /</p>
<p>.lazy</p>
<p>表单输入后失去焦点时更新页面数据，而非实时更新</p>
<p>input v-model.lazy=“msg” /</p>
<p>input 输入框</p>
<p>type=“text”</p>
<p>type=“radio”</p>
<p>type=“checkbox”</p>
<p>type=“xxxx”</p>
<p>textarea</p>
<p>select</p>
<ol start="5">
<li>条件渲染指令<br>条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。</li>
</ol>
<p>v-if 和 v-show<br>v-show 的原理是：动态为元素添加或移除style= “ display: none; “ 样式，从而控制元素的显示与隐藏。</p>
<p>如果要频繁的切换元素的显示状态，用 v-show 性能会更好。<br>v-if 的原理是：每次动态创建或移除 DOM 元素，实现元素的显示和隐藏。</p>
<p>如果在运行时条件很少改变，则使用 v-if 较好。<br>v-if 指令在使用的时候，有两种方式：</p>
<p>直接给定一个布尔值 true 或 false</p>
<p>p v-if=”true”被 v-if 控制的元素/p<br>给 v-if 提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏</p>
<p>p v-if=”type === ‘A’”良好/p<br>v-else-if<br>div v-if=”type === ‘A’”优秀/div<br>div v-else-if=”type === ‘B’”良好/div<br>div v-else-if=”type === ‘C’”及格/div<br>div v-else不及格/div<br>6. 列表渲染指令<br>基于一个数组来循环渲染一个列表结构。</p>
<p>v-for<br>v-for 指令需要使用 item in items 形式的特殊语法</p>
<p>items 是源数据 (待循环) 的数组，而<br>item 被循环的每一项。<br>【示例】：动态渲染表单数据：</p>
<p> link rel=”stylesheet” href=”./lib/bootstrap.css”</p>
<p>   希望 Vue 能够控制下面的这个 div，帮我们把数据填充到 div 内部<br>  div id=”app”<br>    table class=”table table-bordered table-hover table-striped”<br>      thead<br>        th索引/th<br>        thId/th<br>        th姓名/th<br>      /thead<br>      tbody<br>         官方建议：只要用到了 v-for 指令，那么一定要绑定一个 :key 属性<br>         而且，尽量把 id 作为 key 的值<br>         官方对 key 的值类型，是有要求的：字符串或数字类型<br>         key 的值是千万不能重复的，否则会终端报错：Duplicate keys detected<br>        tr v-for=”(item, index) in list” :key=”item.id”<br>          td 双{ index }双/td<br>          td 双{ item.id }双/td<br>          td 双{ item.name }双/td<br>        /tr<br>      /tbody<br>    /table<br>  /div<br>使用 key 维护列表的状态<br>官方推荐, 使用 v-for 指令绑定一个:key 属性，key的作用是为了高效的更新虚拟DOM。</p>
<p>key 的值类型，是有要求的：字符串或数字类型</p>
<p>把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）</p>
<p>改变 data 顺序，index 会重新排序，所以 index 的值不具有唯一性。</p>
<p>计算属性 computed<br>实时监听 data 中数据的变化，并 return 一个计算后的新值， 供组件渲染 DOM 时使用。</p>
<p>可以被模板结构 (插值、v-bind ) 或 methods 方法使用。</p>
<p>但是在某些情况下，我们可能需要对数据进行一些转化后在显示，或者需要将多个数据结合起来进行显示，这时候我们可以使用计算属性。<br>实例 1：</p>
<p>div id=”app”<br>  h2 双{getFullName()}双/h2<br>  h2 双{fullName}双/h2<br>/div</p>
<p>  const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>      firstName: ‘lin’,<br>      lastName: ‘willen’<br>    },<br>    computed: {<br>      fullName () {<br>        return this.firstName + ‘ ‘ + this.lastName;<br>      }<br>    },<br>      使用 methods: 每次都会调用方法<br>    methods: {<br>      getFullName () {<br>        return this.firstName + ‘ ‘ + this.lastName;<br>      }<br>    }<br>  })<br>特点：</p>
<p>定义的时候，要被定义为 “方法”。<br>在使用计算属性的时候，当普通的属性使用即可<br>实现了代码的复用，只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值。<br>实例2：</p>
<p>div id=”app”<br>  h2总价格： 双{totalPrice}双/h2<br>/div</p>
<p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>      books:[<br>        {id: 1001, name: ‘Unix编程艺术’,price: 119},<br>        {id: 1002, name: ‘代码大全’,price: 105},<br>        {id: 1003, name: ‘深入理解计算机原理’,price: 99},<br>        {id: 1004, name: ‘现代操作系统’,price: 109}<br>      ]<br>    },<br>    computed: {<br>      totalPrice () {</p>
<pre><code>    let totalPrice = 0;
    
    for (let i in this.books) &#123;
      totalPrice += this.books[i].price;
    &#125;
      
     也可以使用 for of 
    for (let book of this.books) &#123;
      totalPrice += book.price;
    &#125;
    return totalPrice;
  &#125;
&#125;
</code></pre>
<p>  })<br>计算属性 vs 方法<br>methods和computed看起来都可以实现我们的功能，那么为什么还要多一个计算属性</p>
<p>methods: 每次使用都会调用方法<br>computed: 计算属性会缓存计算的结果, 不变的情况下只调用一次, 除非原属性发生改变，才会重新调用.<br>计算属性 vs 侦听器<br>侧重的应用场景不同侧重的应用场景不同：</p>
<p>计算属性侧重于监听多个值的变化，最终计算并返回一个新值。<br>侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值。<br>vue组件<br>什么是组件化开发 ？</p>
<p>根据封装的思想，把页面上可重用的 UI 结构封装为组件，方便项目的开发和维护。</p>
<p>vue 中的组件化开发</p>
<p>vue 是一个支持组件化开发的前端框架。<br>vue 中组件的后缀名是.vue<br>组件的构成<br>每个 .vue 组件都由 3 部分构成，分别是：</p>
<p>template ：组件的模板结构，且每个组件中必须包含template模板结构。</p>
<p>script ： 组件的 JavaScript 行为</p>
<p>style ：组件的样式</p>
<p> 标签上添加 lang=“less” 属性，即可使用 less 语法编写组件的样式<br> scoped 防止样式冲突</p>
<p>script 节点：<br>（1）script 中的 name 节点</p>
<p>用来定义组件的名称，调试的时候可以清晰的区分每个组件。<br>（2）script 中的 data 节点</p>
<p>组件渲染期间需要用到的数据， data 必须是函数, 不能直接指向对象数据。<br>（3）script 中的 methods 节点</p>
<p>组件中的事件处理函数（方法），必须定义到 methods 节点中<br>注册私有组件<br>通过 components 注册的是私有子组件，被注册的组件只能用在当前组件中。</p>
<p>1.使用 import 语法导入需要的组件</p>
<p>import Left from ‘@/components/Left.vue’<br>2.在 script 标签中使用 components 节点注册组件</p>
<p>script<br>export default {<br>  comments:{<br>    Left<br>  }<br>}<br>/script<br>3.以标签的形式使用刚才注册的组件</p>
<p>template<br>   Left/Left<br>/template<br>注册全局组件<br>在 vue 项目的 main.js 入口文件中，通过 Vue.component()方法，可以注册全局组件。</p>
<p>注册：</p>
<p>import Vue from ‘vue’<br>import App from ‘./App.vue’</p>
<p> 导入需要被全局注册的那个组件<br>import Count from ‘@/components/Count.vue’</p>
<p> 参数一： 组件的 ‘注册名称’，将来以标签形式使用时要求和这个名称一样。<br> 参数二： 需要被全局注册的那个组件。<br>Vue.component(‘MyCount’, Count)</p>
<p> 消息提示的环境配置，设置为开发环境或者生产环境<br>Vue.config.productionTip = false</p>
<p>new Vue({<br>   render 函数中，渲染的是哪个 .vue 组件，那么这个组件就叫做 “根组件”<br>  render: h = h(App)<br>}).$mount(‘#app’)<br>使用：</p>
<p>template<br>     这里需要注意 ‘注册名称’<br>    MyCount /MyCount<br>/template<br>组件注册时名称的大小写<br>在 Vue 定义组件注册名称的方式有两种：</p>
<p>短横线命名法，例如 my-swiper 和 my-search<br>使用组件时也必须使用短横线命名<br>大驼峰命名法，例如 MySwiper 和 MySearch<br>既可以按照大驼峰命名法使用，也可以转化为短横线名称进行使用。<br>注意： 在开发中，推荐使用大驼峰命名法为组件注册名称，因为它的适用性更强。</p>
<p>组件之间的样式冲突问题<br>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。</p>
<p>scoped 属性<br>让当前组件的样式对其子组件是不生效。</p>
<p>Vue 中提供了在style 节点添加 scoped属性，来防止样式冲突问题：</p>
<p>原理是为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域。</p>
<p>template<br>    div class=”container” data-v-001<br>        h3 data-v-001  轮播图组件件/h3<br>    /div<br>/template</p>
<p>style<br>   通过中括号’属性选择器’，防止样式冲突问题<br>   因为每个组件分配的自定义属性是’唯一的’<br> . container[data-v-001]{<br>      border: 1px solid red;<br>    }<br>/style<br>为了提高开发效率和开发体验，直接在 style 节点使用 scoped 属性：</p>
<p>style lang=”less” scoped<br>/style<br>/deep/ 样式穿透<br>让某些样 式对子组件生效。</p>
<p>使用场景： 当使用第三方组件库的时候，需要修改第三方组件默认样式的时候。</p>
<p>style lang=”less” scoped</p>
<p>不加 /deep/ 时，生成的选择器格式为 .title[data-v-052242de]*/<br>.title{<br>    color: blue;<br>}</p>
<p>加/deep/ 时，生成的选择器格式为 [data-v-052242de] .title*/<br>/deep/ .title {<br>  color: pink;<br>}<br>/style<br>Class 与 Style 绑定<br>通过 v-bind动态操作元素样式。</p>
<ol>
<li>动态绑定 HTML 的 class：<br>通过三元表达式，动态的为元素绑定 class 的类名：</li>
</ol>
<p>h3 class=”thin” :class=”isItalic ?’italic’:’’”MyDeep 组件/h3<br>button @click=”isItalic=!lisItalic” Toggle Italic /button</p>
<p>data(){<br>    return { isItalic:true }<br>.thin{<br>    font-weight:200;<br>.italic{<br>    font-style:italic;<br>}<br>2. 以数组语法绑定 HTML 的 class<br>如果元素需要动态绑定多个 class 的类名，此时可以使用数组的语法格式</p>
<p>h3 class=”thin”:class=”[isItalic? ‘italic’: ‘’,isDelete? ‘delete’:’’]”MyDeep组件/h3<br>button @click=”isItalic= !isItalic” 字体变细 /button<br>button @click=”isDelete= !isDelete” 添加删除线 e/button</p>
<p>script<br>export default {<br>  data () {<br>    return {<br>      isItalic: true,<br>      isDelete: false,<br>    }<br>  }<br>}<br>/script<br>3. 以对象语法绑定 HTML 的 class：<br>h3 class=”thin”:class=”classObj”MyDeep组件/h3<br>button @click=”classObj.isItalic = !classObjisItalic” 字体变细 /button<br>button @click=”classObj.isDelete = !classObj.isDelete” 添加删除线 e/button</p>
<p>script<br>export default {<br>  data () {<br>    return {<br>        classObj:{<br>            isItalic: true,<br>              isDelete: false,<br>        }<br>    }<br>  }<br>}<br>/script<br>4. 以对象语法绑定内联的 style<br>命名可以用驼峰式或短横线分隔 (记得用引号括起来) 来命名：</p>
<p>div :style=”{color:active, fontSize: fsize +’px’,’background-color’: bgcolor}”<br>    Hello world!!<br>/div</p>
<p>button @click=”fsize += 1”字号+1/button<br>button @click=”fsize -= 1”字号-1/button</p>
<p>data () {<br>    return {<br>      active: ‘red’,<br>      fsize: 30,<br>      bgcolor: ‘pink’<br>    }<br>}<br>自定义属性 props<br>props是组件的自定义属性，允许使用者通过自定义属性，为当前组件指定初始值，极大的提高组件的复用性。</p>
<p>在组件中声明 prpos<br>my-article 组件的定义如下：</p>
<p>template<br>h3标题： 双{title}双/h3<br>h5作者： 双{author}双/h5<br>/template<br>父组件传递给my-article组件的数据，必须在props节点中声明 :</p>
<p>script<br>    export default {<br>        props:[‘title’,’author’],<br>/script<br>无法使用未声明的 props<br>如果父组件给子组件传递了未声明的 props 属性，则这些属性会被忽略，无法被子组件使用。</p>
<p>动态绑定 props 的值<br>使用 v-bind 属性绑定的形式，可以为组件动态绑定 props 的值。</p>
<p>！–通过V-bind属性绑定，为author动态赋予一个表达式的值</p>
<p>my-article :title=”info.title” :author=”‘post by’+info.author”/my-article<br>props 的大小写命名<br>组件中如果使用“camelCase (驼峰命名法)”声明了 props 属性的名称，则有两种方式为其绑定属性的值：</p>
<p>script<br>    export default {<br>        props:[‘pubTime’],   使用’驼峰命名’法为当前组件声明 pubTime 属性<br>/script<br>使用时既可以用驼峰命名，亦可以用短横线分隔命名的形式为组件绑定属性的值 ：</p>
<p>my-article pubTime=”2021” /my-article<br> 等价于<br>my-article pub-time=”2021” /my-article<br>props 验证<br>基础的类型检查 type</p>
<p>props:{</p>
<p>   支持的8种基础类型</p>
<p>   propA:String,    字符串类型<br>   propB:Number,    数字类型<br>   propC:Boolean,   布尔值类型<br>   propD:Array,     数组类型<br>   propE:Object,    对象类型<br>   propF:Date,      日期类型<br>   propG:Function,  函数类型<br>   propH:Symbol     符号类型</p>
<p>  }<br>多个可能的类型</p>
<p>必填项校验 required</p>
<p>属性默认值 default</p>
<p>props:{<br>     通过数组形式，为当前属性定义多个可能的类型<br>    type: [String, Number],<br>    required: true,<br>    default: 0,<br>}</p>
<p>自定义验证函数<br>在封装组件时，可以为 prop 属性指定自定义的验证函数，从而对 prop 属性的值进行更加精确的控制：</p>
<p> props:{<br>   type:{<br>        通过 validataor函数，对type 属性进行校验，属性值 通过val形参接收<br>     validataor(val){<br>        必须匹配下列字符串中的一个<br>       return [‘success’,’warning’,’danger’].indexOf(val) !== -1<br>     }<br>   }<br>}</p>
<p>prpos 传入不同的初始值<br>在实际开发中我们经常会碰到下面的情况：</p>
<p>在不同组件使用同一个注册的组件时候希望赋值一个不同的初始值。<br>1.组件的封装者通过 props 允许使用者自定义初始值：</p>
<p>template<br>  div<br>    h5Count是全局组件，将被Left 和 Right组件使用/h5<br>    pcount 的值是： 双{ init }双/p<br>    button @click=”count += 1”+1/button<br>  /div<br>/template</p>
<p>script<br>export default {<br>   props: [‘init’],<br>  props: {<br>     自定义属性的名字，是封装者自定义的（只要名称合法即可）<br>    init: {<br>       如果外界使用 Count 组件的时候，没有传递 init 属性，则默认值生效<br>      default: 0,<br>       指定值类型必须是 Number 数字<br>      type: Number,<br>       必填项校验(表示必须传入值)<br>      required: true<br>    }<br>  },</p>
<p>  data() {<br>    return {<br>        props是只读的且不可修改<br>        要想修改 props 的值，可以把 props 的值转存到 data中<br>      count: this.init<br>    }<br>  }<br>}</p>
<p>2.组件的使用者通过属性节点传入初始值</p>
<p>Left 组件、Right 组件：</p>
<p>template<br>  div class=”left-container”<br>    h3Left 组件/h3<br>    hr /<br>    MyCount :init=”9”/MyCount<br>  /div<br>/template</p>
<p>template<br>  div class=”right-container”<br>    h3Right 组件/h3<br>    hr /</p>
<pre><code>MyCount :init=&quot;6&quot;/MyCount
</code></pre>
<p>  /div<br>/template</p>
<p>props 里传参注意点<br>props 可以通过[]给数据定义多个可能的数据类型 ;</p>
<p>props 传入 Object 默认值必须是一个 fn</p>
<p>props: {<br>commCount: {<br>type: String,<br>default: ‘’<br>},<br>pubdate: {<br> 通过数组形式，为当前属性定义多个可能的类型<br>type: [String, Number],<br>default: ‘’<br>},<br>cover: {<br>type: Object,<br> 通过 default 函数，返回 cover 的默认值<br>default: function() {<br> 这个 return 的对象就是 cover 属性的默认值<br>return { cover: 0 }<br>}<br>}<br>}</p>
<p>props 是只读的,想修改 props 的值，可以把 props 的值转存到 data 中。<br>props 的三个属性值：default、type、required。<br>自定义事件<br>封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件。</p>
<p>vue2 中自定义事件的 3 个使用步骤：</p>
<p>在封装组件时 （子组件）：触发自定义事件</p>
<p>在使用组件（父组件）时：监听自定义事件</p>
<p>触发自定义事件<br> 子组件</p>
<p>button @click=”onBtnClick” +1 /button</p>
<p>script<br>export default {<br>    data() {<br>         子组件自己的数据，将来希望把 count 值传给父组件<br>        return { count: 0 }<br>    },<br>    methods: {<br>        onBtnClick() {<br>            this.count t= 1<br>            修改数据时，通过 $emit()触发自定义事件<br>             当点击 ‘+1’ 按钮时 调用this.$emit 触发自定义的 numchange 事件<br>            this.$emit( ‘numchange’)}<br>    }<br>}<br>/script<br>监听自定义事件<br> 父组件<br>Son @numchange=”getNewCount”/Son</p>
<p>methods : {<br>    getNewCount(val) {<br>    console.log(‘监听到了 count 值的变化’, val)<br>}，</p>
<p>自定义事件传参<br>在调用 this.$emit() 方法触发自定义事件时，可以通过第 2 个参数为自定义事件传参:</p>
<p>methods: {<br>    onBtnClick() {<br>        this.count t= 1<br>        this.$emit( ‘numchange’ , this.count)}  触发自定义事件,通过第二个参数传参<br>}</p>
<p>filter 过滤器<br>在 vue 3.x 的版本中剔除了过滤器相关的功能。</p>
<p>在 vue 3.x 使用计算属性或方法代替被剔除的过滤器功能。</p>
<p>过滤器（Filters）常用于文本的格式化。过滤器可以用在两个地方：双括号插值表达式 和v-bind属性绑定。</p>
<p> 在双花括号中通过 | 调用capitalize过滤器，对message值进行格式化<br> 双{ message | capitalize }双</p>
<p> 在 <code>v-bind</code> 中<br>div v-bind:id=”rawId | formatId”/div<br>私有过滤器<br>在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。</p>
<p>创建一个私有过滤器，示例代码如下：</p>
<p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        message: ‘hello world!’,<br>        info: ‘title info’<br>    },<br>     在 filters 节点下定义过滤器<br>    filters: {<br>         把首字母转换为大写的过滤器<br>        capitalize (value) {<br>            return value.charAt(0).toUpperCase() + value.slice(1)<br>        }<br>    }<br>全局过滤器<br>如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器:</p>
<p> Vue.filters()方法接收两个参数：<br> 第一个参数：过滤器名字   第二个参数：过滤器的处理函数</p>
<p>Vue.filter(‘capitalize’,(str)={<br>    return value.charAt(0).toUpperCase() + value.slice(1)’<br>} )<br>调用多个过滤器：<br> 双{ message | filterA | filterB }双<br>1<br>先把 message 的值交给 filterA 处理，再把 filterA 处理结果交给 filterB 进行处理，最终把 filterB 的处理结果，作为最终值渲染到页面上。<br>过滤器传参<br>过滤器是 JavaScript 函数，因此可以接收参数：</p>
<p> 双{ message | filterA(‘arg1’, arg2) }双</p>
<p> 第一个参数永远是 ‘管道符’ 前面待处理的值，第二个参数开始才是调用过滤器时传递的参数</p>
<p>Vue.filter(‘filterA’,(msg,arg1,arg2)={<br>     过滤器的逻辑代码<br>})<br>这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。</p>
<p>p 双{message | cap | maxl(5)}双/p</p>
<p>Vue.filter(‘cap’, (str) = {<br>    return str.charAt(0).toUpperCase() + str.slice(1) + ‘—-‘<br>})</p>
<p>Vue.filter(‘maxl’, (str, len = 10) = {<br>    if (str.length = len) return str<br>    return str.slice(0, len) + ‘….’<br>})<br>var app = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        message: ‘hello Vue 2021年10月30日00:07:45!’<br>    }</p>
<p>过滤器的注意点<br>在过滤器函数中，一定要有 return 值<br>在过滤器的形参中，可以获取到“管道符”前面待处理的那个值<br>如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是”私有过滤器“<br>label的for属性<br>使用lable自带的属性进行单选钮的启用和禁用：</p>
<p>input type=”checkbox” :id=”‘cb’ + item.id” v-model=”item.status”<br>label  :for=”‘cb’ + item.id” v-if=”item.status”已启用/label<br>label  :for=”‘cb’ + item.id” v-else已禁用/label<br>watch 侦听器<br>watch 侦听器 监视数据的变化，从而针对数据的变化做特定的操作。</p>
<p>侦听器的格式<br>方法格式的侦听器<br>无法在刚进入页面的时候，自动触发！！<br>如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器！<br>对象格式的侦听器<br>可以通过 immediate 选项，让侦听器自动触发！<br>可以通过 deep 选项，让侦听器深度监听对象中每个属性的变化！<br>使用方法格式创建的侦听器：</p>
<p>监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用：</p>
<p>import axios from ‘axios’</p>
<p>export default{<br>    data(){<br>        return{ username: ‘’}<br>    }<br>},<br>watch: {<br>     newVal 是’变化后的新值’，oldVal 是’变化之前的旧值’<br>    async username(newVal,oldVal) {<br>        if (newVal === ‘’) return<br>         使用 axios 发起请求，判断用户名是否可用<br>        const { data: res } = await axios.get(<code>https:www.escook.cn/api/finduser/$&#123;newVal&#125;</code> )<br>        console.log(res)<br>    }<br>}</p>
<p>使用方法创建时：组件在初次加载完毕后不会调用 watch 侦听器。</p>
<p>immediate 选项<br>如果想让 watch 侦听器在浏览器打开时立即被调用，则需要使 用 immediate 选项。</p>
<p>使用对象格式创建的侦听器：</p>
<p>watch: {<br>    username: {<br>         handler 是固定写法，表示当 username 的值变化时，自动调用 handler 处理函数<br>        async handler(newVal,oldVal) {<br>            if (newVal === ‘’) return<br>            const { data: res } = await axios.get(‘https:<a target="_blank" rel="noopener" href="http://www.escook.cn/api/finduser/&#39;">www.escook.cn/api/finduser/&#39;</a> + newVal)<br>            console.log(res)<br>        },<br>             表示页面初次渲染好之后，就立即触发当前的 watch 侦听器<br>            immediate: true<br>    }<br>}<br>使用 handler 定义侦听器函数<br>immediate控制侦听器是否自动触发， 默认值为 false不立即触发。<br>deep 选项<br>如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 开启 深度监听。</p>
<p>input type=”text” v-model.trim=”username”/</p>
<p>data: {<br>   info: {username: ‘admin’}<br>},<br>watch:{<br>     监听info对象的变化<br>    info:{<br>          handler(newVal){<br>            console.log(newVal.username)<br>        },<br>     开启深度监听，监听每个属性值的变化，默认值为 false<br>    deep: true<br>    }<br>}<br>监听对象单个属性的变化<br>如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器。</p>
<p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        info: {username: ‘admin’,}<br>    },<br>    watch:{<br>        ‘info.username’:{<br>            handler(newVal){<br>                console.log(newVal)<br>            },<br>        }<br>    }<br>})<br>组件的生命周期<br>生命周期（Life Cycle）是指一个组件从创建 - 运行 - 销毁的整个阶段，强调的是一个时间段。<br>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。<br>生命周期强调的是时间段，生命周期函数强调的是时间点。</p>
<p>生命周期函数的分类<br>生命周期图示:</p>
<p>需要注意的三个周期函数：</p>
<p>在实际开发中，created 是最常用的生命周期函数 ！</p>
<p>组件之间的数据共享</p>
<p>父→子<br>父组件通过 v-bind 属性绑定向子组件共享数据，子组件使用 props接收数据。</p>
<p> 父组件<br> 注册子组件<br>Son :msg=”message” :user=”userinfo”/Son</p>
<p>script<br>     导入子组件<br>    import Son from ‘@component/Son.vue’</p>
<p>export default {<br>    data:{<br>        return{<br>        message:’hello vue.js’<br>        userinfo:{<br>        name: ‘lilei’,age: 21<br>    },<br>    components: {<br>        Son<br>            }<br>        }<br>    }<br>}<br>/script</p>
<p> 子组件<br>template<br>    div<br>        h5Son组件/h5<br>        p父组件传递过来的 msg值是:  双{ msg }/p<br>        p父组件传递过来的user值是:  双{ user }双/p<br>    /div<br>/template</p>
<p>export default {<br>    props: [ ‘msg’ , ‘user ‘]<br>}<br>子 → 父<br>子组件向父组件共享数据使用自定义事件。</p>
<p> 子组件</p>
<p>export default {<br>    data() {<br>         子组件自己的数据，将来希望把 count 值传给父组件<br>        return { count: 0 }<br>    },<br>    methods: {<br>        add() {<br>            this.count t= 1<br>            修改数据时，通过 $emit()触发自定义事件<br>            this.$emit( ‘numchange’ , this.count)}<br>    }<br>}</p>
<p> 父组件<br>h1App 根组件/h1<br>h3子组件传过来的数据是 ：  双{ countFromSon }双/h3<br>Son @numchange=”getNewCount” /Son</p>
<p>script<br>import Son from ‘@component/Son.vue’</p>
<p>export default {<br>    data() {<br>        return { countFromSon: 0 }<br>    },<br>    methods : {<br>        getNewCount(val) {<br>            console.log(‘numchange 事件被触发了！’, val)<br>            this.countFromSon = val<br>        }，<br>        components: {<br>        Son<br>    }<br>}<br>}<br>    /script</p>
<p>兄弟组件数据共享<br>在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus。</p>
<p>EventBus 的使用步骤</p>
<p>创建 eventBus.js模块，并向外共享一个 Vue 的实例对象<br>在数据发送方，调用 bus.$emit(‘事件名称’, 要发送的数据)方法触发自定义事件 。<br>在数据接收方，调用 bus.$on(‘事件名称’, 事件处理函数)方法注册一个自定义事件。<br>ref 引用 操作DOM<br>不依赖于 jQuery 和调用 DOM API 的情况下，获取 DOM 元素或组件的引用。</p>
<p>每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下，组件的 $refs 指向一个空对象。</p>
<p>使用 ref 引用 DOM 元素<br>！–使用ref属性，为对应的DOM添加引用名称 </p>
<p>h3 ref=”myh3”MyRef 组件/h3<br>button@click=”getRef”获取$refs 引用/button</p>
<p>methods:{<br>    getRef(){<br>        通过this.$refs.引用的名称可以获取到DOM元素的引用<br>        console.log(this.$refs.myh3)<br>        操作DOM元素，把文本颜色改为红色<br>        this.$refs.myh3.style.color=’red’<br>}，<br>使用 ref 引用组件实例<br>需求： 在根组件控制子组件</p>
<p>！–使用ref属性，为对应的“组件”添加引用名称 </p>
<p>my-counter ref=”counterRef” /my-counter<br>button @click=”getRef” 获取$refs 引用 /button</p>
<p>methods:{<br>    getRef（）{<br>         通过this.$refs.引用的名称可以引用组件的实例<br>        console.log（this.$refs.counterRef）<br>         引用到组件的实例之后，就可以调用 子组件上的 methods 方法<br>        this.$refs.counterRef.add（）<br>}，<br>点击文本框自动获得焦点<br>添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。</p>
<p>this.$nextTick(cb) 方法<br>$nextTick(cb)保证 cb 回调函数可以操作到最新的 DOM 元素（推迟到下一个 DOM 更新周期之后执行）。</p>
<p>解决我们在页面没有渲染完成前使用 ref 操作DOM元素报错问题。<br>控制文本框和按钮的按需切换<br>点击按钮展示文本框，文本框输入时隐藏按钮：</p>
<p>template<br>    input type=”text” v-if=”inputVisible” ref=”ipt”<br>    button v-else @click=”showInput”展示input输入框/button<br>/template</p>
<p>script<br>export default{<br>    data(){<br>        return{<br>        控制文本框和按钮的按需切换<br>        inputVisible:false，<br>}，<br>methods:{<br>    showInput(){<br>        切换布尔值，显示文本框<br>        this.inputVisible=true</p>
<pre><code>    获取文本框的DOM引用，并调用.focus（）使其自动获得焦点
    
     this.$refs.ipt.focus（） 错误，此时页面未渲染完毕，无法获取文本框
    
    把对input文本框的操作，推迟到下次DOM更新之后。否则页面上根本不存在文本框元素
    this.$nextTick(() =&#123;
            this.$refs.ipt.focus（）
    &#125;）
&#125;
</code></pre>
<p>}，<br>    /script<br>动态组件<br>实现不同组件之间的按需展示。( 动态切换组件显示和隐藏 ) ，类似于 Vue-Router。</p>
<p>动态组件的基本使用<br>Vue 提供了一个内置的 component组件，专门用来实现动态组件的渲染 :</p>
<p>component 标签是 vue 内置的，作用：组件的占位符</p>
<p>通过 :is 属性，动态指定要渲染的组件</p>
<p>is 属性的值，表示要渲染的组件的名字。</p>
<p>is 属性的值，应该是组件在 components 节点下的注册名称。</p>
<p>使用 keep-alive保持组件的状态 （避免组件切换时重新渲染）。</p>
<p>keep-alive 会把内部的组件进行缓存，而不是销毁组件。<br>通过 include 指定哪些组件需要被缓存。</p>
<p>通过 exclude属性指定哪些组件不需要被缓存。</p>
<p> 点击按钮，动态切换组件的名称</p>
<p>button @click=“comName = ‘Left’”展示 Left<br>button @click=“comName = ‘Right’”展示 Right</p>
<p>在组件中定义 name 名称：<br>当提供了 name 属性之后，组件的名称就是 name 属性的值。</p>
<p>export default {<br>name: ‘MyRight’<br>}</p>
<p>声明 name 应用场景：结合keep-alive标签实现组件缓存功能；以及在调试工具中看到组件的 name 名称。</p>
<p>插槽 slot<br>在签形式使用的组件中内容节点中插入内容。</p>
<p>通过 slot 元素 定义插槽，从而为用户预留内容占位符。<br>封装组件时，没有预留插槽的内容会被丢弃。<br>后备内容<br>在 slot 标签内添加的内容会被作为后备内容。</p>
<p> 子组件 my-com<br>template<br>    slot这是后备内容/slot<br>/template</p>
<p> 使用插槽<br>    my-com<br>        如果用户没有提供内容，上面 slot标签 内定义的内容会生效，此时页面会有 “这是后备内容”<br>        如过提供了，下面的 img 将会被渲染到页面上<br>        img src=”../assets/log.png” alt=””<br>    /my-com<br>具名插槽<br> MyArticle 组件<br>template<br>div class=”container”<br>    header<br>        slot name=”header”/slot<br>    /header<br>    main<br>        slot/slot<br>    /main<br>    footer<br>        slot name=”footer”/slot<br>    /footer<br>    /div<br>/template<br>Vue 官方规定，每个 slot插槽，都要有一个 name名称，一个不带 name 的 slot 出口会带有隐含的名字“default”。<br>为具名插槽提供内容<br>如果要把内容填充到指定名称的插槽中，我们可以在一个 template 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p>
<p>MyArticle</p>
<pre><code>template v-slot:header
     把内容放在 MyArticle组件的 header 标签内
    h1如今最好，没有来日方长。/h1
/template

 上一个代码块中，main 标签未指定具名插槽，所以默认渲染到 main标签中
p现在是2021年11月7日 22点05分 星期天/p
p今天不仅是周日，也是冬至/p

template #footer   
    p最后，祝大家冬至快乐！/p
/template
</code></pre>
<p>/MyArticle<br>v-slot:可以简写 #。例如 v-slot:header 可以被重写为 #header。</p>
<p>v-slot 属性只能放在 组件标签和 template 元素上 (否则会报错)。</p>
<p>作用域插槽<br>在封装组件的过程中，可以为预留的slot插槽绑定 props 数据，这种带有 props 数据的slot 叫做“作用域插槽”。示例代码如下：</p>
<p>template<br>    div<br>        h1 这是 Left 组件/h1<br>        ！–下面的slot 是一个作用域插槽<br>         slot v-for=”item in list” :user=”item”/slot<br>    /div<br>  /template<br>接收作用域插槽对外提供的数据, 使用解构赋值简化数据的接收过程 :</p>
<p>！– 使用自定义组件<br>Left<br>  ！–作用域插槽对外提供的数据对象，可以通过“解构赋值”简化接收的过程<br>  template #default=”{user}”<br>        tr<br>            td 双{user.id}双/td<br>            td 双{user.name}双/td<br>            td 双{user.state}双/td<br>        /tr<br>  /template<br>/Left<br>自定义指令<br>vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令。</p>
<p>私有自定义指令 directives: { }<br>在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令。</p>
<ol>
<li>定义一个私有自定义指令：<br>directives:{<br> color:{<pre><code> 为绑定到的HTML元素设置红色的文字
 bind(el)&#123;
     形参中的el是绑定了此指令的、原生的DOM对象
     el.style.color=‘red&#39;
 &#125;
</code></pre>
</li>
<li>使用自定义指令：<br>使用自定义指令时，需要加上v-指令前缀</li>
</ol>
<p>！–声明自定义指令时，指令的名字是color 使用时就是 v-color  </p>
<p>App组件<br>3. 为自定义指令动态绑定参数值<br>在 template 结构中使用自定义指令时，可以通过等号 = 的方式，为当前指令动态绑定参数值：</p>
<p>template</p>
<p>！–在使用指令时，动态为当前指令绑定参数值 color<br>h1 v-color=”color”App组件/h1</p>
<p>/template</p>
<p>data(){<br>    return{<br>    color:’red’<br>}<br>4. 通过 binding 获取指令的参数值：<br>在上面的实例中我们为自定义指令绑定了一个动态的参数值，如何拿到这个值呢 ？</p>
<p>在声明自定义指令时，可以通过形参中的第二个参数，来接收指令的参数值</p>
<p>h1 v-color=”color”App组件/h1</p>
<p> 此时传入的是字符串，不会在data 数据中查找<br>p v-color=”‘blue’” /p</p>
<p>directives:{<br>    color:{<br>        bind(el，binding){<br>            通过binding对象的.value属性，获取动态的参数值<br>            el.style.color=binding.value<br>}<br>5. 使用 update 函数更新 DOM<br>update 函数会在每次 DOM 更新时被调用。</p>
<p>注意：在 vue3 的项目中使用自定义指令时， bind 必须改为 mounted 、 update 改为 updated 。</p>
<p>bind 函数只调用 1 次：当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。</p>
<p>directives:{<br>    color:{<br>        当指令第一次被绑定到元素时被调用<br>        bind(el，binding){<br>            el.style.color=binding.value<br>    }，<br>        每次DOM更新时被调用<br>        update(el，binding){<br>            el.style.color=binding.value<br>    }<br>10<br>6. 同时使用 bind 和 update 函数简写<br>如果 bind 和 update 函数中的 逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：</p>
<p>directives:{<br>    在 bind 和 update 时，会触发相同的业务逻辑<br>    color( el，binding ){<br>        el.style.color=binding.value<br>}<br>全局自定义指令 Vue.directive ()<br>通过“ Vue.directive()” 进行声明 。</p>
<p>注意：在使用 Vue-cli ( 脚手架) 时，要把全局自定义指令写在main.js文件中：</p>
<p>参数1：字符串，表示全局自定义指令的名字<br>参数2：对象，用来接收指令的参数值</p>
<p>Vue.directive(‘color’，function(el，binding){<br>        el.style.color=binding.value<br>})</p>
<p> 简写<br>Vue.directive（’color’，(el，binding) ={<br>        el.style.color=binding.value<br>})<br>vue-cli<br>Vue CLI 是官方发布的vue.js项目脚手架, 可以快速搭建vue开发环境以及Webpack配置。</p>
<p>安装和使用<br>一、安装Vue脚手架</p>
<p>npm install -g @vue/cli<br>1<br>二、创建项目</p>
<p>vue create project(项目名称)<br>1<br>目录详解：</p>
<p>|- public          静态页面目录<br>    |- index.html  项目入口<br>|- src             源码目录<br>    |- assets      存放项目中用到的静态资源文件，例如：css 样式表、图片资源<br>    |- components      封装的、可复用的组件，都要放到 components 目录下<br>    |- App.vue         根组件<br>    |- main.js         项目的入口文件。整个项目的运行，要先执行<br>vue 项目的运行流程：</p>
<p>通过 main.js把 App.vue渲染到index.html的指定区域中。</p>
<p>App.vue 用来编写待渲染的模板结构<br>index.html 中需要预留一个 el 区域<br>main.js 把 App.vue 渲染到了 index.html 所预留的区域中<br>axios<br>axios 是一个专注于网络请求的库， 调用 axios 方法得到的返回值是 Promise 对象。</p>
<p>axios 的基本使用<br>发起 GET 请求：</p>
<p>axios({<br>   请求方式<br>  method: ‘GET’,<br>   请求的地址<br>  url: ‘http:<a target="_blank" rel="noopener" href="http://www.liulongbin.top:3006/api/getbooks&#39;">www.liulongbin.top:3006/api/getbooks&#39;</a>,</p>
<p>   URL 中的查询参数（GET请求传参）<br>  params: {<br>    id: 1<br>  }<br>}).then(function (result) {<br>  console.log(result)<br>})<br>params 表示传递到服务器端的数据，以url参数的形式拼接在请求地址后面<br>如 ： params: { page:1,per:3 }<br>最终生成：http:jsonplaceholder.typicode.com/page=1&amp;per=3<br>发起 POST 请求：</p>
<p>document.querySelector(‘#btnPost’).addEventListener(‘click’, async function () {</p>
<p>   如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！<br>   await 只能用在被 async “修饰”的方法中</p>
<ol>
<li>调用 axios 之后，使用 async/await 进行简化</li>
<li>使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来</li>
<li>把解构出来的data属性，使用冒号进行重命名，一般都重命名为 { data: res }</li>
</ol>
<p>  const { data: res } = await axios({<br>    method: ‘POST’,<br>    url: ‘http:<a target="_blank" rel="noopener" href="http://www.liulongbin.top:3006/api/post&#39;">www.liulongbin.top:3006/api/post&#39;</a>,</p>
<pre><code>  POST请求体传参
data: &#123;
  name: &#39;zs&#39;,
  age: 20
&#125;
</code></pre>
<p>  })</p>
<p>  console.log(res)<br>})</p>
<p>axios 封装的 6 个属性：</p>
<p>axios 在请求到数据之后，在真正的数据之外，套了一层外壳。</p>
<p>{<br>    config:{ },<br>     data 才是服务器返回的真实数据<br>    data:{<br>        status: 200,<br>        msg: “获取数据成功！”,<br>        data: Array(6)<br>    },<br>    headers:{ … },<br>    request:{ },<br>    status: 200,<br>    statusText: ‘OK’,<br>}<br>axios直接发起GET和POST请求<br>document.querySelector(‘#btnGET’).addEventListener(‘click’, async function () {<br>     axios.get(‘url地址’, {<br>         GET 参数<br>        params: {}<br>      }) */</p>
<pre><code>const &#123; data: res &#125; = await axios.get(&#39;http:www.liulongbin.top:3006/api/getbooks&#39;, &#123;
    params: &#123; id: 1 &#125;
&#125;)
console.log(res)
</code></pre>
<p>})</p>
<p>document.querySelector(‘#btnPOST’).addEventListener(‘click’, async function () {<br>     axios.post(‘url’, {  POST 请求体数据 */ })<br>    const { data: res } = await axios.post(‘http:<a target="_blank" rel="noopener" href="http://www.liulongbin.top:3006/api/post&#39;">www.liulongbin.top:3006/api/post&#39;</a>, { name: ‘zs’, gender: ‘女’ })<br>    console.log(res)<br>})<br>17<br>在 Vue-cli 中使用 axios<br>一般我们会直接这么用：</p>
<p> 在组件内<br>template<br>    button @click=”postInfo”发起 POST 请求/button<br>/template</p>
<p>script</p>
<ol>
<li>导入 axios<br>import axios from ‘axios’<br>export default {</li>
<li>在 methods 定义 axios请求方法<br>methods: {<br>async postInfo() {<br>  const { data: res } = await axios.post(‘http:<a target="_blank" rel="noopener" href="http://www.liaoyia.top:3306/api/post&#39;">www.liaoyia.top:3306/api/post&#39;</a>, { name: ‘zs’, age: 20 })<br>  console.log(res)<br>}<br>}<br>}<br>/script<br>缺点： 在每次使用时候都要导入 axios 文件，写请求地址 (对后期维护不友好) 。</li>
</ol>
<p>把 axios 挂载到 Vue原型上并配置请求根路径<br>避免重复导入axios 和重复写入完整请求地址。</p>
<p>在main.js中配置</p>
<p>import Vue from ‘vue’<br>import App from ‘./App.vue’<br>import axios from ‘axios’</p>
<p>Vue.config.productionTip = false</p>
<p> 全局配置 axios 的请求根路径 (官方提供配置项)<br>axios.defaults.baseURL = ‘http:<a href="http://www.liaoyia.top:3006&#39;">www.liaoyia.top:3006&#39;</a></p>
<p> 把 axios 挂载到 Vue.prototype 上，供每个 .vue 组件的实例直接使用<br>Vue.prototype.$http = axios</p>
<p> 今后，在每个 .vue 组件中要发起请求，直接调用 this.$http.xxx<br> 但是，把 axios 挂载到 Vue 原型上，有一个缺点：不利于 API 接口的复用！！！</p>
<p>new Vue({<br>  render: h = h(App)<br>}).$mount(‘#app’)</p>
<p>使用：</p>
<p>template<br>     button @click=”btnGetBooks”获取图书列表的数据/button<br>/template</p>
<p>script<br>export default {<br>  methods: {<br>     点击按钮，获取图书列表的数据<br>    async btnGetBooks() {<br>      const { data: res } = await this.$http.get(‘/api/getbooks’)<br>      console.log(res)<br>    }<br>  }<br>}<br>/script<br>但是把 axios 挂载到 Vue原型上并配置请求根路径也有缺点：</p>
<p>无法实现API接口的复用 : 在多个组件想使用同一个请求方法(API)的时候，只能在每个组件重新定义一次。</p>
<p>axios 封装<br>1.如果项目中有多个请求地址，我们可以根据多个地址使用工厂模式封装 js 模块，创建多个 axios 实例对象，并设置请求根路径 (baseURL) ：</p>
<p>步骤如下： 在项目的 src目录下创建utils文件夹并新建一个 request.js文件：</p>
<p>import axiox from ‘axios’</p>
<p>const request =axiox.create({<br>    baseURL会在发送请求的时候拼接在url参数的前面<br>    baseURL:’http:jsonplaceholder.typicode.com/‘,</p>
<pre><code>timeout:5000
</code></pre>
<p>})</p>
<p> 向外导出<br>export default  request<br>使用这种方法时： 一般我们只会在一个 js 模块创建一个axios 实例对象，并向外导出。<br>如果有多个服务器地址，那就创建多个 js模块，并在里面创建axios实例对象。<br>2.为了实现复用性，我们还可以把所有请求，都封装在API模块里，在API模块中，按需导出一个方法，这个方法调用 request.get 或 request.post 来请求一个接口，最后return 一个Promise 对象。</p>
<p>比如想调用接口获取用户相关信息：</p>
<p>在根目录新建 utils 文件夹并在里面新建 userAPI.js 文件</p>
<p>导入 utils 文件夹下的 request.js</p>
<p>import request from ‘@/utils/request.js’</p>
<p>export const getArticleListAPI = function(_page, _limit) {<br>  return request.get(‘/articles’, {<br>    params: {<br>      _page,<br>      _limit<br>    }<br>  })<br>}</p>
<p>【实例】：点击按钮发起 GET 请求并自动调用请求拦截和添加响应拦截器：</p>
<p>template<br>  div class=”home”<br>    button @click=”getByMineHandle”调用封装的get请求/button<br>  /div<br>/template</p>
<p>script<br>  导入 get 方法<br>import  { get } from ‘../utils/request’</p>
<p>export default {<br>  name: ‘Home’,<br>  methods:{</p>
<pre><code>getByMineHandle()&#123;
  get(&#39;&#39;,&#123;page:3,per:2&#125;).
  then(res=console.log(res))
&#125;
</code></pre>
<p>  }<br>}<br>/script</p>
<p>import axiox from ‘axios’</p>
<p>const instance =axiox.create({<br>    baseURL会在发送请求的时候拼接在url参数的前面<br>    baseURL:’http:jsonplaceholder.typicode.com/‘,<br>    timeout:5000<br>})</p>
<p>请求拦截<br> 所有的网络请求都会先走这个方法<br> 添加请求拦截器,所有的网络请求都会先走这个方法<br> 我们可以在它里面为请求添加一些自定义的内容 比如 token 或者在 headers 提供信息<br>instance.interceptors.request.use(function (config) {<br>     在发送请求之前做些什么<br>    console.group(‘全局请求拦截’)<br>    console.log(config)<br>    console.groupEnd()<br>    config.headers.token =’12343’<br>    return config;<br>}, function (error) {<br>     对请求错误做些什么<br>    return Promise.reject(error);<br>});</p>
<p> 添加响应拦截器<br>此处可以根据服务器的返回状态码做响应的处理<br>404 404 500<br>instance.interceptors.response.use(function (response) {<br>     对响应数据做点什么<br>    console.group(‘全局响应拦截’)<br>    console.log(response)<br>    console.groupEnd()<br>    return response;<br>}, function (error) {<br>     对响应错误做点什么<br>    return Promise.reject(error);<br>});</p>
<p> 从服务器查看获取数据<br>export function get(url,params) {<br>    return instance.get(url,{<br>        params<br>    })<br>}</p>
<p> 向服务器创建数据<br>export function post(url,data) {<br>    return instance.post(url,data)<br>}</p>
<p> 从服务器删除数据<br>export  function del(url) {<br>    return instance.delete(url)<br>}</p>
<p>  向服务器发送更新数据<br>export  function put(url,data) {<br>    return instance.put(url,data)<br>}</p>
<p>Vue-router<br>SPA 与前端路由<br>SPA (单页面网页)，所有组件的展示与切换都在这唯一的一个页面内完成。</p>
<p>此时，不同组件之间的切换需要依赖 前端路由(router)来实现。</p>
<p>什么是前端路由？</p>
<p>Hash 地址与组件之间的对应关系，不同的Hash 展示不同的页面。</p>
<p>前端路由的工作方式：</p>
<p>vue-router 的基本用法<br>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p>
<p>安装 vue-router 包</p>
<p>npm i <a href="mailto:&#118;&#x75;&#101;&#45;&#114;&#111;&#117;&#x74;&#x65;&#114;&#x40;&#x33;&#x2e;&#x35;&#x2e;&#x32;">&#118;&#x75;&#101;&#45;&#114;&#111;&#117;&#x74;&#x65;&#114;&#x40;&#x33;&#x2e;&#x35;&#x2e;&#x32;</a> -S<br>1<br>此时 src 源码目录下会新增一个 router 文件夹。</p>
<p>创建路由模块</p>
<p>在 src 源代码目录下，新建 router/index.js 路由模块，并初始化：</p>
<p>1.导入Vue和VueRouter的包import Vue from’vue’<br>import VueRouter from‘vue-router’</p>
<p>2.调用Vue.use（）函数，把VueRouter 安装为Vue的插件<br>Vue.use（VueRouter）</p>
<p>3.创建路由的实例对象<br>const router=new VueRouter（）</p>
<p>4.向外共享路由的实例对象<br>export default router<br>导入并挂载路由模块<br>在 src/main.js 入口文件中，导入并挂载路由模块：</p>
<p>import Vue from’vue’<br>import App from’./App.vue’</p>
<p>1.导入路由模块<br>import router from@/router’</p>
<p>new Vue ({<br>render:h=h（App），</p>
<p>2.挂载路由模块<br>router:router<br>}).$mount(‘#app’)<br>声明路由链接和占位符</p>
<p>在 src/App.vue 组件中，使用 vue-router 提供的 router-link 和router-view声明路由链接和占位符:</p>
<p>tcmplate<br>    div class=”app-container”<br>        h1App组件/h1</p>
<pre><code>    ！--1.定义路由链接 
    router-link to=&quot;/home&quot;首页/router-link
    router-link to=&quot;/movie&quot;电影/router-link
    router-link to=&quot;/about&quot;关于/router-link
    
    ！--2.定义路由的占位符 
    router-view/router-view
/div
</code></pre>
<p>/template<br>声明路由的匹配规则<br>在 src/router/index.js 路由模块中，通过 routes 数组声明路由的匹配规则：<br>导入需要使用路由切换展示的组件</p>
<p>import Home from‘@/components/Home.vue’<br>import Movie from‘@/components/Movie.vue’<br>import About from‘@/components/About.vue’</p>
<p>2.创建路由的实例对象<br>const router=new VueRouter({<br>    在routes数组中，声明路由的匹配规则<br>    routes:[<br>        path 表示要匹配的hash地址；component表示要展示的路由组件<br>        {path:’/home’，component: Home}，<br>        {path:’/movie’，component: Movie}，<br>        {path:’/about’，component: About}<br>]<br>})<br>路由重定向<br>当访问地址 A 的时候，强制用户跳转 到地址C, 从而展示特定的组件页面。</p>
<p>通过路由规则的 redirect 属性，指定一个新的路由地址来实现路由的重定向。<br>下面这个应用场景，当用户访问网页 / 目录时候，跳转到首页：</p>
<p>const router=new VueRouter({<br>在routes数组中，声明路由的匹配规则<br>    routes:[<br>        当用户访问 / 的时候，通过 redirect 属性跳转到 /home 对应的路由规则<br>        { path: ‘/‘，redirect:’/home’ }，<br>        { path: ‘/home’，component: Home }，<br>        { path: ‘/movie’，component: Movie }，<br>        { path: ‘/about’，component: About }<br>})<br>————————————————<br>src/router/index.js 就是当前任务的路由模块  </p>
<ol>
<li>导入 Vue 和 VueRouter 的包  </li>
<li>调用 Vue.use() 函数, 把 VueRouter 安装为 Vue 的插件  </li>
<li>创建路由的实例对象<br>const router = new VueRouter({<br>routes是一个数组，作用:定义“hash 地址”与“组件”之间的对应关系<br>routes: [<br>{ path: ‘/‘, redirect: ‘/home’ },<br>{ path: ‘/Home’, component: Home },<br>{ path: ‘/Left/:id’, component: Left, props: true },  :id是动态生成id<br>{<br>  path: ‘/Right’,<br>  component: Right,<br>  redirect: ‘/Right/tab1’,<br>  children: [  <pre><code> 子路由规则  
 默认子路由:如果children数组中，某个路由规则的path值为空字  
 符串，则这条路由规则，叫做“默认子路由”  
&#123; path: &#39;&#39;, component: Tab1 &#125;,  默认子路由  
&#123; path: &#39;tab1&#39;, component: Tab1 &#125;,  
&#123; path: &#39;tab2&#39;, component: Tab2 &#125;  
</code></pre>
  ]<br>}<br>]<br>}<br>)<br>vue-router提供了许多编程式导航的API,其中最常用的导航API分别是:<br>①this.$router.push(‘hash 地址’)<br>●跳转到指定 hash地址，并增加一条历史记录<br>②this.$router.replace(‘hash 地址’)<br>●跳转到指定的hash地址，并替换掉当前的历史记录<br>③this.$router.go(数值 n)<br>go(-1) 表示后退一层<br>如果后退的层数超过上限，则原地不动<br>$router.go的简化用法<br>在实际开发中，一般只会前进和后退一层页面。因此vue-router提供了如下两个便捷方法:<br>①$router.back()<br>●在历史记录中， 后退到上一一个页面<br>②$router.forward()<br>●在历史记录中， 前进到下一个页面<br>为router实例对象声明全局前置导航守卫<br>只要发生了路由的跳转，必定会触发 beforeEach 指定的function回调函数<br>router.beforeEach(function (to, from, next) {<br>to是将要访问的路由的信息对象<br>from是将要离开的路由的信息对象<br>next是一个函数，调用next() 表示放行，允许这次路由导航</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.guaguablog.online">GuaGuaSuaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.guaguablog.online/2022/11/16/Vue2-Notes/">https://www.guaguablog.online/2022/11/16/Vue2-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.guaguablog.online" target="_blank">GuaGua's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/vue.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/06/26/Java-Notes/"><img class="next-cover" src="/images/java.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java Notes</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GuaGuaSuaka</div><div class="author-info__description">BLOG</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/guaguam"><i class="fab fa-github"></i><span>路远且长</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/guaguam" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1960595339@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/Vue2-Notes/" title="Vue2 Notes"><img src="/images/vue.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue2 Notes"/></a><div class="content"><a class="title" href="/2022/11/16/Vue2-Notes/" title="Vue2 Notes">Vue2 Notes</a><time datetime="2022-11-16T13:16:37.000Z" title="发表于 2022-11-16 21:16:37">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/26/Java-Notes/" title="Java Notes"><img src="/images/java.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Notes"/></a><div class="content"><a class="title" href="/2022/06/26/Java-Notes/" title="Java Notes">Java Notes</a><time datetime="2022-06-26T01:18:00.000Z" title="发表于 2022-06-26 09:18:00">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/26/C-Notes/" title="C Notes"><img src="/images/c.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C Notes"/></a><div class="content"><a class="title" href="/2020/06/26/C-Notes/" title="C Notes">C Notes</a><time datetime="2020-06-26T01:18:00.000Z" title="发表于 2020-06-26 09:18:00">2020-06-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By GuaGuaSuaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="15" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>