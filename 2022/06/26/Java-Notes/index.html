<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java Notes | GuaGua's BLOG</title><meta name="author" content="GuaGuaSuaka"><meta name="copyright" content="GuaGuaSuaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Java 一、标识符规则 1.标识符由英文字母大小写，0~9，_或$组成。 2.数字不可开头。 3.不能使用关键字和保留字，但可以包含关键字和保留字 4.JAVA中严格区分大小写，标识符长度无限制。 5.标识符不能含空格。   *提示：凡是自己可以起名字的地方都叫标识符。   二、JAVA中命名规范（行业规范） 1.包名：多单词组成，所有字母都小写，xxyyzz. 2.类名、接口名：多单词组成，所">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Notes">
<meta property="og:url" content="https://www.guaguablog.online/2022/06/26/Java-Notes/index.html">
<meta property="og:site_name" content="GuaGua&#39;s BLOG">
<meta property="og:description" content="Java 一、标识符规则 1.标识符由英文字母大小写，0~9，_或$组成。 2.数字不可开头。 3.不能使用关键字和保留字，但可以包含关键字和保留字 4.JAVA中严格区分大小写，标识符长度无限制。 5.标识符不能含空格。   *提示：凡是自己可以起名字的地方都叫标识符。   二、JAVA中命名规范（行业规范） 1.包名：多单词组成，所有字母都小写，xxyyzz. 2.类名、接口名：多单词组成，所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.guaguablog.online/images/java.jpeg">
<meta property="article:published_time" content="2022-06-26T01:18:00.000Z">
<meta property="article:modified_time" content="2022-11-16T13:55:26.263Z">
<meta property="article:author" content="GuaGuaSuaka">
<meta property="article:tag" content="BLOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.guaguablog.online/images/java.jpeg"><link rel="shortcut icon" href="/images/1.jpeg"><link rel="canonical" href="https://www.guaguablog.online/2022/06/26/Java-Notes/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-11-16 21:55:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/java.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GuaGua's BLOG</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-26T01:18:00.000Z" title="发表于 2022-06-26 09:18:00">2022-06-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-16T13:55:26.263Z" title="更新于 2022-11-16 21:55:26">2022-11-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Java</p>
<p>一、标识符规则</p>
<p>1.标识符由英文字母大小写，0~9，_或$组成。</p>
<p>2.数字不可开头。</p>
<p>3.不能使用关键字和保留字，但可以包含关键字和保留字</p>
<p>4.JAVA中严格区分大小写，标识符长度无限制。</p>
<p>5.标识符不能含空格。</p>
<p> </p>
<p>*提示：凡是自己可以起名字的地方都叫标识符。</p>
<p> </p>
<p>二、JAVA中命名规范（行业规范）</p>
<p>1.包名：多单词组成，所有字母都小写，xxyyzz.</p>
<p>2.类名、接口名：多单词组成，所有单词首字母大写：XxYyZz.</p>
<p>3.变量名、方法名 ：多单词组成时，第一个单词首字母小写，第二个单词开始首字母大写：xxxYyyZzz</p>
<p>4.常量名：所有字母大写，多单词用下划线连接:XXX_YYY_ZZZ</p>
<p> </p>
<p>可变个数的形参:</p>
<p>         *  1.可变个数的形参的格式:数据类型 … 变量名</p>
<p>         *  2.当调用可变个数形参的方法时，传入的参数个数可以是:0个,1个,2个…….</p>
<p>         *  3.可变个数形参的方法与本类中方法名相同,形参不同的方法之间构成重载</p>
<p>         *  4.可变个数形参的方法与本类中方法名相同,形参类型也相同的数组之间不构成重载，二者不能共存</p>
<p>         *  5.可变个数形参在方法的形参中,必须声明在末尾,有且只能有一个</p>
<p> </p>
<p> </p>
<p>方法的重载(overload) loading…</p>
<p> * 1.定义:在同一个类中，允许存在一个以上的同名方法,只要他们的参数个数或者参数类型不同即可</p>
<p> *</p>
<p> * “两同一不同”:同一个类、相同方法名</p>
<p> *              参数列表不同、参数个数不同、参数类型不同</p>
<p> *</p>
<p> * 2.判断是否是重载:</p>
<p> *      跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系!</p>
<p> *</p>
<p> * 3.在通过对象调用方法时，如何确定某一个指定的方法:</p>
<p> *      方法名—&gt; 参数列表</p>
<p> </p>
<p>初始化方式一:int arr[][] = new int[4][3];</p>
<p>    外层元素初始化值为地址值</p>
<p>    内存元素初始化值与一维数组初始化情况相同</p>
<p>   </p>
<p>    初始化方式而:int arr[][] = new int[4][];</p>
<p>    外层元素初始化值为null</p>
<p>    内存元素不能调用，否则报错</p>
<p> </p>
<p>Java面向对象学习的三条主线:</p>
<p>//1.Java类及类的成员:属性、方法、构造器;代码块、内部类</p>
<p>//2.面向对象的三大特征:封装性、继承性、多态性</p>
<p>//3.其他关键字:this、super、static、final、abstract、interface、package、import等</p>
<p>// 类和对象的使用:</p>
<p>// 1.创建类，设计类的成员</p>
<p>// 2.创建类的对象</p>
<p>// 3.通过”对象.属性”或”对象.方法”调用对象的结构</p>
<p> </p>
<p>//属性(成员变量) vs 局部变量</p>
<p>//1.相同点:</p>
<p>//  (1)定义变量的格式:数据类型 变量名 = 变量值</p>
<p>//  (2)先声明，后使用</p>
<p>//  (3)变量都有其对应的作用域</p>
<p>//</p>
<p>//2/不同点:</p>
<p>//  (1)在类中声明的位置不同</p>
<p>//      属性:直接定义在类的一对{}内</p>
<p>//</p>
<p>//      局部变量:声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
<p>//</p>
<p>//  (2)关于权限修饰符的不同</p>
<p>//      属性:可以在声明属性时，指名其权限，使用权限修饰符。</p>
<p>//      常用的权限修饰符:private、public、缺省、protected   –&gt;封装性</p>
<p>//      目前，声明属性时，都使用缺省就可以了</p>
<p>//</p>
<p>//      局部变量:不可以使用权限修饰符</p>
<p>//  (3)默认初始化值的情况</p>
<p>//      属性:类的属性，根据其类型，都有默认初始化值。</p>
<p>//      整型(byte,short,int,long):0</p>
<p>//      浮点型(float,double):0.0</p>
<p>//      字符型(char):0</p>
<p>//      布尔类型(boolean):false</p>
<p>//      引用数据类型(类,接口,数组):null</p>
<p>//      局部变量:没有默认初始化值</p>
<p>//          意味着,我们在调用局部变量时,一定要是显式赋值</p>
<p>//          特别地：形参在调用时,我们赋值即可</p>
<p>//</p>
<p>//  (4)在内存中加载的位置</p>
<p>//      属性:加载到堆空间中(非static)</p>
<p>//</p>
<p>//      局部变量:加载到栈空间</p>
<p>关于变量的赋值</p>
<p>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p>
<p> </p>
<p>方法的形参的传递机制:</p>
<p>①值传递</p>
<p>1.形参:方法定义时，声明的小括号内的参数</p>
<p>实参:方法调用时，实际传递给形参的数据</p>
<p>②值传递机制</p>
<p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p>
<p>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p>
<p> </p>
<p>递归方法的使用</p>
<p>1.递归方法:一个方法体内调用它本身</p>
<p>2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p>
<p>递归一定要向已知反向递归，否则这种递归就变成了无穷递归，类似于死循环。</p>
<p> </p>
<p>面向对象的特征二:</p>
<p>一、继承性的好处:</p>
<p>①减少了代码的冗余:提高了代码的复用性</p>
<p>②便于功能的扩展</p>
<p>③为之后的多态性的使用提供了前提</p>
<p> </p>
<p>二、继承性的格式:class A extends B{}</p>
<p>A:子类、派生类、subclass<br>B:父类、超类、基类、superclass<br> <br>体现:一旦子类A继承父类B以后，子类A中就获取了父类<br>B中声明的所有的属性、方法<br>特别的:父类中声明为private的属性或方法，子类继承父类<br>以后，仍然认为获取了父类中私有的结构。<br>只是因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的扩展<br>子类和父类的关系不同于子集和集合的关系。</p>
<p>Extends:扩展</p>
<p>三、Java中关于继承性的规定:</p>
<p>1.一个类可以被多个子类继承<br>2.JAVA中的类的单继承性:一个类只能有一个父类<br>3.子父类是相对的概率。<br>4.子类直接继承的父类称为:直接父类;间接继承的父类称为:间接父类<br>5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
<p>四、</p>
<p>1.如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类<br>2.所有的JAVA类(除java.lang.Object类之外)都直接或间接的继承于java.lang.Object类<br>3.意味着，所有的java类具有java.lang.Object类声明的功能。</p>
<p>面向对象的特征一:封装与隐藏</p>
<p>一、问题的引入:</p>
<p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。<br>这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。<br>但是在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属<br>性声明时体现，我们只能通过方法进行限制条件的添加。<br>同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为<br>私有的。—&gt;此时，针对于属性就体现了封装性。</p>
<p>二、封装性的体现:</p>
<p>我们将类的属性xxx私有化(private)，同时，提供公共的方法(public)来获取(getXxx)和设置(set)<br>属性的值。</p>
<p>拓展:</p>
<p>封装性的体现:<br>①如上<br>②不对外暴露的私有的方法<br>③单例模式<br>……</p>
<p>三、封装性的体现，需要权限修饰符来配合</p>
<p>1.Java规定的四种权限</p>
<p>①private<br>②缺省<br>③protected<br>④public</p>
<p>2.四种权限可以用来修饰类及类的内部结构:属性、方法、构造器、内部类。</p>
<p>3.四种权限都可以用来修饰类的内部结构:属性、方法、构造器、内部类</p>
<p>修饰类的话，只能使用:缺省、public</p>
<p>总结：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小。</p>
<p> </p>
<p>属性赋值的先后顺序</p>
<p>①默认初始化</p>
<p>②显式初始化</p>
<p>③构造器中初始化</p>
<p>④通过”对象.方法” 或 “对象.属性”的方式赋值</p>
<p> </p>
<p>以上操作的先后顺序:① – ② – ③ – ④</p>
<p>this关键字的使用：</p>
<p>1.this可以用来修饰:属性、方法、构造器</p>
<p>2.this修饰属性和方法:this理解为当前对象或当前正在创建的对象</p>
<p>在类(或构造器)的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象(或正在创建的)属性或方法。但是，我们通常情况下，我们都选择省略”this.”。特殊情况下，如果方法(构造器)的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p>
<p>3.this调用构造器</p>
<p>①我们在类的构造器中，可以显式的使用”this(形参列表)”方法，调用本类中的其他构造器<br>②构造器中不能通过”this(形参列表)”调用自己<br>③如果一个类中有n个构造器，则最多有n-1个构造器中使用了”this(形参列表)”<br>④规定:”this(形参列表)”必须声明在当前构造器的首行<br>⑤构造器内部最多只能声明一个”this(形参列表)”，用来调用其他的构造器</p>
<p>一、package关键字的使用</p>
<p>1.为了更好的实现项目中类的管理，提供包的概念</p>
<p>2.使用package声明类或接口所属的包，声明在源文件的首行</p>
<p>3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、”见命知意”</p>
<p>4.每”.”一次，就代表一层文件目录。</p>
<p> </p>
<p>补充:同一个包下，不能命名同名的接口、类</p>
<p>不同的包下，可以命名同名的接口、类</p>
<p> </p>
<p>二、import关键字的作用</p>
<p>import导入</p>
<p>1.在源文件中显式的使用import结构导入指定包下的类、接口</p>
<p>2.声明在包的声明和类的声明之间</p>
<p>3.如果需要导入多个结构，则并列写出即可</p>
<p>4.可以使用”xxx.*“的方式表示可以导入xxx包下的所有结构</p>
<p>5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
<p>6.如果使用的类或接口是本包下定义的，则可以省略import结构</p>
<p>7.如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示</p>
<p>8.使用”xxx.*“方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p>
<p> </p>
<p>9.import static:导入指定类或接口中的静态结构:属性或方法(很少使用)</p>
<p><img src="../../_resources/image1.png" alt="image1"></p>
<p>方法的重写</p>
<p>1.重写:子类继承父类以后，可以对父类中同名同参数的方法，就行覆盖操作</p>
<p>2.应用:重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法</p>
<p>时，实际执行的是子类重写父类的方法</p>
<p>3.重写的规定:</p>
<p>方法的声明: 权限修饰符 返回值类型 方法名 throws 异常的类型(形参列表){方法体}<br>约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法<br>①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符<br>&gt;特殊情况，子类中不能重写父类中声明为private权限的方法<br>③返回值类型<br>&gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型也得是void<br>&gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类<br>&gt;父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的数据类型<br>④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型<br>子类和父类中同名同参数的方法要么都声明为非static的，要么都声明为static的。(不是重写)</p>
<p>类的结构之三:构造器</p>
<p>一、构造器的作用:</p>
<p>1.创建对象<br>2.初始化对象的信息</p>
<p>二、说明</p>
<p>1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br>2.定义构造器的格式:权限修饰符 类名(形参列表){…}<br>3.一个类中定义的多个构造器，彼此构成重载<br>4.一代我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器了</p>
<p> </p>
<p>super关键字的使用</p>
<p>1.super理解为:父类的</p>
<p>2.super可以用来调用:属性、方法、构造器</p>
<p>3.super的使用</p>
<p>1.我们可以在子类的方法或构造器中，通过使用”super.属性”或<br>“super.方法”的方式，显式的调用父类中声明的属性或方法。<br>但是，通常情况下，我们习惯省略”super.”<br>2.特殊情况:当子类和父类中定义了同名的属性中，我们要在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。<br>3.特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</p>
<p>4.super调用构造器</p>
<p>1.我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定构造器<br>2.”super(形参列表)”的使用，必须声明在子类构造器的首行<br>3.我们在类的构造器中，针对于”super(形参列表)”或”this(形参列表)”只能二选一<br>4.在构造器的首行，没有显式的声明”super(形参列表)”或”this(形参列表)”则默认调用的是父类中空参的构造器:super();<br>5.在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)，调用父类的构造器</p>
<p>子类对象实例化的全过程</p>
<p>1.从结果上看:(继承性)</p>
<p>子类继承父类以后，就获取了父类中声明的属性或方法<br>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</p>
<p> </p>
<p>2.从过程上来看:</p>
<p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的<br>构造器，进而调用父类的父类的构造器，直接调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</p>
<p>明确:虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为你new的子类对象。</p>
<p>单例设计模式:</p>
<p>1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一一个对象实例。</p>
<p>2.如何实现?</p>
<p>饿汉式Vs懒汉式</p>
<p>3.区分饿汉式和懒汉式</p>
<p>饿汉式:坏处:对象加载时间过长<br>好处:饿汉式是线程安全的<br>懒汉式: 好处:延迟对象的创建。<br>坏处:线程不安全</p>
<p>面向对象特征之三:多态性</p>
<p>1.理解多态性:可以理解为一个事物的多种形态。<br>2.何为多态性:<br>对象的多态性:父类的引用指向子类的对象<br>3.多态的使用:虚拟方法调用<br>有了对象的多态性以后，我们在编译器，只能调用父类中声明的方法<br>总结:编译看左边；运行看右边<br>4.多态性的使用前提:①类的继承关系<br>②方法的重写<br>5.对象的多态性只适用于方法，不适用于属性(编译和运行都看左边)</p>
<p>main( )方法的使用说明:</p>
<p>1. main( )方法作为程序的入口</p>
<p>2. main( )方法也是一 一个普通的静态方法</p>
<p>3. main( )方法可以作为我们与控制台交互的方式。 (之前:使用Scanner)</p>
<p> </p>
<p>类的成员之四:代码块(或初始化块)</p>
<p>1.代码块的作用:用来初始化类、对象</p>
<p>2.代码块如果有修饰的话，只能使用static.</p>
<p>3.分类:静态代码块 VS 非静态代码块</p>
<p>4.静态代码块</p>
<p>&gt;内部可以有输出语句<br>&gt;随着类的加载而执行，而且只执行一-次<br>&gt;作用:初始化类的信息<br>&gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>&gt;静态代码块的执行要优先于非静态代码块的执行<br>&gt;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的属性和方法
 </p>
<p>5.非静态代码块</p>
<p>&gt;内部可以有输出语句<br>&gt;随着对象的创建而执行<br>&gt;每创建一个对象， 就执行一次非静态代码块<br>&gt;作用:可以在创建对象时，对对象的属性等进行初始化<br>&gt;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>&gt;非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法
 </p>
<p>对属性可以赋值的位置:</p>
<p>①默认初始化</p>
<p>②显式初始化</p>
<p>③构造器中初始化</p>
<p>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p>
<p>⑤在代码块中赋值</p>
<p> </p>
<p>Java.lagng.Object类</p>
<p>1.1Object类是所有Java类的根父类</p>
<p>2.如果在类的声明中未使用extends关键字指明其父类，则默认</p>
<p>父类为java.lang.Object类</p>
<p>3.Object类中的功能(属性、方法)就具有通用性</p>
<p>4.Object类只声明了一个空参的构造器</p>
<p> </p>
<p>instanceof关键字的使用</p>
<p>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</p>
<p>使用情景:为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先</p>
<p>进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不就行向下转型</p>
<p> </p>
<p>如果a instanceof A返回true，则a instanceof B也返回true</p>
<p>其中，类B是类A的父类</p>
<p>二、equals( )方法的使用:</p>
<p>1.是一个方法，而非运算符</p>
<p>2.只能适用于引用数据类型</p>
<p>3. Object类中equals( )的定义:</p>
<p>Public boolean equals(Object obj)<br>{<br>Return(this == obj)<br>}<br>说明:Object类中定义的equals()和==的作用是相同的:<br>比较两个对象的地址值是否相同，即两个引用是否指向相同的变量</p>
<p>4.像String、Data、File、包装类等都重写了Object类中的equals()方法，重写以后比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p>
<p>5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的实体内容是否相同。那么，我们就需要对Object类中的equals()进行重写</p>
<p>1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，</p>
<p>系统将不可能把父类里的方法转移到子类中:编译看左边，运行看右边</p>
<p>2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，</p>
<p>这个实例变量依然不可能覆盖父类中定义的实例变量:编译运行都看左边</p>
<p> </p>
<p>static关键字的使用</p>
<p>1.static:静态的</p>
<p>2.static可以用来修饰:属性、方法、代码块、内部类</p>
<p>3.用static修饰属性:静态变量</p>
<p>1.属性按是否用static修饰分为:静态属性、非静态属性(实例变量)<br>实例变量:我们创建了类的多个对象，每个对象都拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。<br> <br>静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，其他对象调用此静态变量时是修改过了的。<br>2.static修饰属性的其他说明:<br>①静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用<br>②静态变量的加载早于对象的创建<br>③由于类只会加载一次，则静态变量在内存中也只会存在一份:存在方法区的静态域中<br>④ 类变量 实例变量<br>类 yes no<br>对象 yes yes<br>3.静态属性举例:</p>
<p>4.用static修饰方法:静态方法</p>
<p>①随着类的加载而加载，可以通过”类.静态方法”的方式进行调用。<br>② 静态方法 非静态方法<br>类 yes no<br>对象 yes yes<br>③静态方法中，只能调用静态的方法或属性<br>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</p>
<p>5.static注意点</p>
<p>1.在静态的方法内，不能使用this和super关键字<br>2.关于静态属性和静态方法的使用，大家都从生命周期的角度去理解
 </p>
<p>6.开发中，如何确定一个属性是否要声明为static的？</p>
<p>&gt;属性是可以被多个对象所共享的，不会随着对象的不同而不同的</p>
<p>开发中，如何确定一个方法是否要声明为static的？</p>
<p>&gt;操作静态属性的方法，通常设置为static的<br>&gt;工具类中的方法，习惯上声明为static的。比如:Math、Arrays</p>
<p>final :最终的</p>
<p>1. final可以用来修饰的结构:类、方法、变量</p>
<p>2. final用来修饰一一个类:此类不能被其他类所继承。</p>
<p>比如: String类、System类、StringBuffer类</p>
<p>3. final用来修饰方法:表明此方法不可以被重写</p>
<p>比如: object类中getClass();</p>
<p>4. final用来修饰变量:此时的”变量”就称为是一 个常量</p>
<p>4.1 final修饰属性:<br>可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化<br>4.2 final修饰局部变量:<br>尤其是使用final修饰形参时，表明此形参是一一个常量。当我们调用此方法时，给常量形参赋一一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
 </p>
<p>static final 用来修饰属性:全局常量</p>
<p> </p>
<p>abstract关键字的使用</p>
<p>1. abstract:抽象的</p>
<p>2. abstract可以用来修饰的结构:类、方法</p>
<p>3. abstract修饰类:抽象类</p>
<p>&gt;此类不能实例化<br>&gt;抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程)<br>&gt;开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
<p>4. abstract修饰方法:抽象方法</p>
<p>&gt;抽象方法只有方法的声明， 没有方法体<br>&gt;包含抽象方法的类，-定是一一个抽象类。反之，抽象类中可以没有抽象方法的。<br>&gt;若子类重写了 父类中的所有的抽象方法后，此子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类， 需要使用abstract修饰</p>
<p>abstract使用上的注意点:</p>
<p>1.abstract不能用来修饰:属性、构造器等结构<br>2.abstract不能用来修饰私有方法、静态方法、final方法、final类</p>
<p>接口的使用</p>
<p>1.接口使用interface来定义</p>
<p>2.Java中，接口和类是并列的两个结构</p>
<p>3.如何定义接口:定义接口中的成员</p>
<p>3.1 JDK7及以前:只能定义全局常量和抽象方法<br>&gt;全局常量: public static final的. 但是书写时，可以省略不写<br>&gt;抽象方法: public abstract的<br>3.2 JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)</p>
<p>4.接口中不能定义构造器的!意味着接口不可以实例化</p>
<p>5. Java开发中，接口通过让类去实现( implements )的方式来使用.</p>
<p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化<br>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p>
<p>6. Java类可以实现多个接口 — &gt;弥补了Java单继承性的局限性</p>
<p>格式: class AA extends BB implements CC,DD,EE</p>
<p>7.接口与接口之间可以继承，而且可以多继承</p>
<p>8.接口的具体使用，体现了多态性</p>
<p>9.接口，实际上可以看做是一种规范</p>
<p> </p>
<p>接口的使用</p>
<p>1.接口使用上也满足多态性</p>
<p>2.接口，实际上就是定义了一种规范</p>
<p>3.开发中，体会面向接口编程!</p>
<p> </p>
<p>JKD8中接口的新特性</p>
<p>知识点1:接口中定义的静态方法，只能通过接口来调用。</p>
<p>知识点2:通过实现类的对象，可以调用接口中的默认方法。</p>
<p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p>
<p>知识点3:如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。– &gt;类优先原则</p>
<p>知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错。– &gt;接口冲突。这就需要我们必须在实现类中重写此方法</p>
<p>知识点5:在子类(或实现类)的方法中调用父类、接口中被重写的方法 接口名.super.方法名()</p>
<p>类的内部成员之五:内部类</p>
<p>1. Java中 允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p>
<p>2.内部类的分类:成员内部类(静态、非静态) Vs 局部内部类(方法内、代码块内、构造器内)</p>
<p>3.成员内部类:</p>
<p>一方面，作为外部类的成员:<br>&gt;调用外部类的结构<br>&gt;可以被static修饰<br>&gt;可以被4种不同的权限修饰<br>另一方面，作为一个类:<br>&gt;类内可以定义属性、方法、构造器等<br>&gt;可以被final修饰， 表示此类不能被继承。言外之意，不使用final,就可以被继承<br>&gt;可以被abstract修饰</p>
<p> </p>
<p>一、异常体系结构</p>
<p>java. lang. Throwable</p>
<p>—–java. lang. Error:-般不编写针对性的代码进行处理。<br>—–java. lang. Exception:可以进行异常的处理<br>—–j编译时异常( checked)<br>—–jIoException<br>—–FileNot FoundException<br>—–ClassNotFoundException<br>——运行时异常(unchecked )<br>—– NullPointerException<br>—– ArrayIndexOutOfBounds Exception<br>—–ClassCastException<br>—– NumberF ormatException<br>—– InputMi smatchException<br>—– ArithmeticException</p>
<p> </p>
<p>说明:</p>
<p>1. finally是 可选的。</p>
<p>2.使用try将可能出现异常代码包装起来，在执行过程中，-旦出现异常，就会生成-一个对应异常类</p>
<p>的对象，根据此对的类型，去catch中进行匹配。</p>
<p>3.一旦try中的异常对象匹配到某一 个catch时，就进入catch中进行异常的处理。一旦处理完成，</p>
<p>就跳出当前的try-catch结构(在没有写finally的情况)。继续执行其后的代码</p>
<p>4. catch中的异常类型如果没有子父类关系， 则谁声明在上，谁声明在下无所谓。</p>
<p>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p>
<p>5.常用的异常对象处理的方式:①String getMessage( ) ②printStackTrace()</p>
<p>6.在try结构中声明的变量，再出了try结构以后，就不能再被调用</p>
<p>7.try-catch-finally结构可以嵌套</p>
<p> </p>
<p>体会:使用try-catch- finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p>
<p>体会2:开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，针对于编译时异常，我们说一定要考虑异常的处理。</p>
<p> </p>
<p>try-catch-finally中finally的使用:</p>
<p>1. finally是可选的</p>
<p>2. finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
<p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能 自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
<p>异常处理的方式二: throws +异常类型</p>
<p>1. “throws +异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</p>
<p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象， 此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行!</p>
<p>2.体会: try-catch-finally :真正的将异常给处理掉了。</p>
<p>throws的方式只是将异常抛给了方法的调用者。并没有真正将 异常处理掉。</p>
<p>3.开发中如何选择使用try-catch-finally还是使用throws?</p>
<p>1如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws,意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。<br> <br>2执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throw的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p>
<p> </p>
<p>方法重写的规则之一:</p>
<p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
 </p>
<p>如何自定义异常类?</p>
<p>1.继承于现有的异常结构: RuntimeException 、Exception<br>2.提供全局常量: serialVersionUID<br>3.提供重载的构造器</p>
<p> </p>
<p>一、异常的处理:抓抛模型</p>
<p>过程一: “抛”:程序在正常执行的过程中，-旦出现异常，就会在异常代码处生成一一个对应异常类的对象。并将此对象抛出。<br>一旦抛出对象以后，其后的代码就不再执行。</p>
<p>关于异常对象的产生:①系统自动生成的异常对象</p>
<p>②手动的生成一一个异常对象，并抛出(throw)</p>
<p>过程二: “抓”: 可以理解为异常的处理方式:①try-catch-finally ② throws</p>
<p> </p>
<p>测试Thread中的常用方法:</p>
<p>1. start(): 启动当前线程;调用当前线程的run()</p>
<p>2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
<p>3. currentThread():静态方法， 返回执行当前代码的线程</p>
<p>4. getName():获取当前线程的名字</p>
<p>5. setName(): 设置当前线程的名字</p>
<p>6. yield():释放当前cpu 的执行权</p>
<p>7. join(): 在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p>
<p>8. stop():已过时。当执行此方法时，强制结束当前线程。</p>
<p>9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。 在指定的millitime毫秒时间内，当前线程是阻塞状态。</p>
<p>10. isAlive(): 判断当前线程是否存活</p>
<p>线程的优先级:</p>
<p>1.MAX_ PRIORITY: 10</p>
<p>MIN_PRIORITY: 1</p>
<p>NORM_ PRIORITY: 5 –&gt;默认 优先级</p>
<p>2.如何获取和设置当前线程的优先级:</p>
<p>getPriority():获取线程的优先级</p>
<p>setpriority(int p): 设置线程的优先级</p>
<p> </p>
<p>说明:高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</p>
<p>多线程的创建，方式一:继承于Thread类</p>
<p>* 1.创建一个继承于Thread类的子类</p>
<p>* 2.重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</p>
<p>* 3.创建Thread类的子类的对象</p>
<p>* 4.通过此对象调用start()</p>
<p>创建多线程的方式二:实现Runnable接口</p>
<p>1.创建-一个实现了Runnable接口的类</p>
<p>2. 实现类去实现Runnable中的抽象方法: run()</p>
<p>3.创建实现类的对象</p>
<p>4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p>
<p>5.通过Thread类的对象调用start()</p>
<p> </p>
<p>比较创建线程的两种方式。</p>
<p>开发中:优先选择:实现Runnable接口的方式</p>
<p>原因: 1.实现的方式没有类的单继承性的局限性</p>
<p>2.实现的方式更适合来处理多个线程有共享数据的情况。</p>
<p>联系: public class Thread impl ements Runnable</p>
<p>相同点:两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<p>例子:创建三个窗口卖票，总粟数为100张使用实现Runnable接口的方式</p>
<p>1.问题:卖粟过程中，出现了重票、错粟–&gt;出现了线程的安全问题</p>
<p>2.问题出现的原因:当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票</p>
<p>3.如何解决:当-一个线程a在操作ticket的时候， 其他线程不能参与进来。 直到线程a操作完ticket时，线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变</p>
<p>4.在Java中， 我们通过同步机制，来解决线程的安全问题。</p>
<p>方式一:同步代码块</p>
<p>synchronized(同步监视器){</p>
<p>// 需要被同步的代码</p>
<p>}</p>
<p>5.同步的方式，解决了线程的安全问题。—好处</p>
<p>操作同步代码时，只能有一 个线程参与，其他线程等待。相当于是-一个单线程的过程，效率低。</p>
<p>说明: 1. 操作共享数据的代码，即为需要被同步的代码 –&gt;不能包含代码多了，也不能包含代码少</p>
<p>2.共享数据:多个线程共同操作的变量。比如: ticket 就是共享数据。<br>3.同步监视器，俗称:锁。任何一个类的对象，都可以充当锁。<br> <br>补充:在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。
 </p>
<p>要求:多个线程必须要共用同一把锁。</p>
<p> </p>
<p>方式二:同步方法</p>
<p>如果操作共享数据的代码完整的声明在一一个方法中，我们不妨将此方法声明同步的。</p>
<p>关于同步方法的总结:</p>
<p>1.同步方法仍然涉及到同步监视器，只是不需要我 们显式的声明。</p>
<p>2.非静态的同步方法，同步监视器是: this</p>
<p>静态的同步方法，同步监视器是:当前类本身</p>
<p> </p>
<p>演示线程的死锁问题</p>
<p>1.死锁的理解:不同的线程分别占用对方需要的同步资源不放弃，</p>
<p>都在等待对方放弃自己需要的同步资源，就形成J线程的死锁</p>
<p>2.说明:</p>
<p>1)出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继缕</p>
<p>2)我们使用同步时，要避免出现死锁。</p>
<p>解决线程安全问题的方式三: Lock锁— JDK5.日新增</p>
<p>1.面试题: synchronized 与Lock的异同?</p>
<p>相同:二者都可以解决线程安全问题<br>不同: synchronized机 制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步(lock())，同时结束同步也需要手动的实现(unlock() )</p>
<p>线程通信的例子:使用两个线程打印1-100。 线程1,线程2交替打印</p>
<p>涉及到的三个方法:</p>
<p>wait():- -旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</p>
<p>notify():-旦执行此方法，就会唤醒被wait的-一个线程。如果有多个线程被wait,就唤醒优先级高的线程</p>
<p>notifyAll():-旦执行此方法，就会唤醒所有被wait的线程。</p>
<p> </p>
<p>说明:</p>
<p>1.wait(), notify()， notifyAll()三个方法必须使用在同步代码块或同步方法中。</p>
<p>2.wait(), notify(), notifyALl()三个方法的调用者必须是同步代码块或同步方法中的同步监视器</p>
<p>否则，会出现ILlegaLMoni torStateException异常</p>
<p>3. wait(), notify(), notifyALL()三个方法是定义在java. lang. object类中。</p>
<p>面试题: sLeep() 和wait()的异同?</p>
<p>1.相同点:一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<p>2.不同点:</p>
<p>1)两个方法声明的位置不同: Thread类中声明sleep() ，object类中声明wait()</p>
<p>2)调用的要求不同: sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p>
<p>3)关于是否释放同步监视器:如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，wait()会释放同步监视器</p>
<p> </p>
<p><strong>应用线程池的好处：</strong></p>
<ul>
<li><p>  提高响应速度（减少了创建新线程的时间）</p>
</li>
<li><p>  降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
</li>
<li><p>便于线程管理<br>  corePoolSize：核心池的大小<br>  maximumPoolSize：最大线程数<br>  keepAliveTime：线程没任务时最多保持多长时间后会终止</p>
</li>
</ul>
<p>创建线程的方式三:实现Callable接口。— JDK 5.0新增</p>
<ul>
<li><p>  创建一个实现Callable的实现类</p>
</li>
<li><p>  实现call方法，将此线程需要执行的操作声明在call()中</p>
</li>
<li><p>  创建Callable接口实现类的对象</p>
</li>
<li><p>  将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</p>
</li>
<li><p>  将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</p>
</li>
<li><p>  获取Callable中call方法的返回值</p>
</li>
</ul>
<p> </p>
<p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大?</p>
<p>1. call()可以有返回值的。<br>2. call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>3. Callable是支持泛型的</p>
<p> </p>
<p> </p>
<p>String:字符串，使用一对””引起来表示。</p>
<p>1. String声明为final的，不可被继承</p>
<p>2. String实现TSerializable接口:表示字符串是支持序列化的。</p>
<p>实现了Comparable接口:表示String 可以比较大小</p>
<p>3. String内部定义了final char[] value用于存储字符串数据</p>
<p>4. String:代表不可变的字符序列。简称:不可变性。</p>
<p>体现:</p>
<p>1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值<br>3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值</p>
<p>5.通过字面量的方式(区别于new)给-一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
<p>6.字符串常量池中是不会存储相同内容的字符串的。</p>
<p> </p>
<p>String、StringBuffer、 StringBuilder三者的异同?</p>
<p>String:不可变的字符序列;底层使用char[]存储</p>
<p>StringBuffer:可变的字符序列;线程安全的，效率低;底层使用char[]存储</p>
<p>StringBuilder:可变的字符序列; jdk5. 日新增的，线程不安全的，效率高;底层使用char[]存储</p>
<p>对比String、StringBuffer、 StringBuilder三者的效率:</p>
<p>从高到低排列: StringBuilder &gt; StringBuffer &gt; String</p>
<p>java. util.Date类</p>
<p>—-java. sql. Date类</p>
<p>1.两个构造器的使用</p>
<p>&gt;构造器- -: Date():创建一个对应当前时间的Date对象<br>&gt;构造器二:创建指定毫秒数的Date对象</p>
<p>2.两个方法的使用</p>
<p>&gt;toString():显示当前的年、月、日、时、分、秒<br>&gt;getTime():获取当前Date对象对应的毫秒数。(时间戳)</p>
<p>3. java. sqL. Date对应着数据库中的日期类型的变量</p>
<p>&gt;如何实例化<br>&gt;如何将java. util. Date对象转换为java. sql. Date对象</p>
<p>一、说明: Java中的对象，正常情况下，只能进行比较: ==或!=。不能使用&gt;或&lt;的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实?使用两个接口中的任何一个: Comparable 或Comparator</p>
<p>Comparable,接口的使用举例:</p>
<p>1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式</p>
<p>2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</p>
<p>3.重写compareTo(obj)的规则:</p>
<p>如果当前对象this.大于形参对象obj,则返回正整数,<br>如果当前对象this小于形参对象obj,则返回负整数,<br>如果当前对象this等于形参对象obj,则返回零。</p>
<p>4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</p>
<p>在compareTo(obj)方法中指明如何排序</p>
<p>Comparator接口的使用:定制排序</p>
<p>1.背景:</p>
<p>当元素的类型没有实现java. Lang. Comparable接口而又不方便修改代码,或者实现了java. lang<br>. Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序</p>
<p> </p>
<p>2.重写compare(Object o1, Object o2)方法，比较o1和o2的大小:</p>
<p>如果方法返回正整数，则表示01大于o2;<br>如果返回e，表示相等;<br>返回负整数，表示o1小于o2。
 </p>
<p>一、说明: Java中的对象，正常情况下，只能进行比较: ==或!=。不能使用&gt;或&lt;的</p>
<p>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。<br>如何实现?使用两个接口中的任何一个: Comparable 或Comparator
 </p>
<p>二、Comparable 接口与Comparator的使用的对比:</p>
<p>Comparable接口的方式一旦指定，保证Comparable 接口实现类的对象在任何位置都可以比较大小<br>Comparator.接口属于临时性的比较。</p>
<p>一、枚举类的使用</p>
<p>1.枚举类的理解:类的对象只有有限个，确定的。我们称此类为枚举类<br>2.当需要定义一-组常量时，强烈建议使用枚举类<br>3.如果枚举类中只有一一个对象，则可以作为单例模式的实现方式。</p>
<p>二、如何定义枚举类</p>
<p>方式一: jdk5.0之前， 自定义枚举类<br>方式二: jdk5.0， 可以使用enum关键字定义枚举类</p>
<p>三、Enum类中的常用方法: .</p>
<p>values()方法:返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。<br>value0f(String str):可以把一 -个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象<br>tostring():返回当前枚举类对象常量的名称</p>
<p>四、使用enum关键字定义的枚举类实现接口的情况</p>
<p>情况一:实现接口,在enum类中实现抽象方法<br>情况二:让枚举类的对象分别实现接口中的抽象方法</p>
<p> </p>
<p>一、注解的使用<br>① jdk 5.0 新增的功能<br>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。<br>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的 name = value 对中。<br>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android 中注占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。<br>⑤ 框架 = 注解 + 反射机制 + 设计模式<br> <br>二、注解的使用示例<br>示例一：生成文档相关的注解</p>
<ul>
<li><p>  @author 标明开发该类模块的作者，多个作者之间使用，分割 @version 标明该类模块的版本；</p>
</li>
<li><p>  @see 参考转向，也就是相关主题；</p>
</li>
<li><p>  @since 从哪个版本开始增加的；</p>
</li>
<li><p>  @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常就不能写；</p>
</li>
<li><p>  其中 @param 、 @return 和 @exception 这三个标记都是只用于方法的。</p>
</li>
<li><p>  @param 的格式要求：@param 形参名形参类型形参说明；</p>
</li>
<li><p>  @return 的格式要求：@return 返回值类型返回值说明；</p>
</li>
<li><p>  @exception 的格式要求：@exception 异常类型异常说明；</p>
</li>
<li><p>  @param 和 @exception 可以并列多个；</p>
</li>
</ul>
<p>示例二：在编译时进行格式检查(JDK内置的个基本注解)<br>@Override: 限定重写父类方法, 该注解只能用于方法；<br>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；<br>@SuppressWarnings: 抑制编译器警告；<br>三、如何自定义注解</p>
<ul>
<li><p>  注解声明为：@interface</p>
</li>
<li><p>  内部定义成员，通常使用value表示</p>
</li>
<li><p>  可以指定成员的默认值，使用default定义</p>
</li>
<li><p>  如果自定义注解没成员，表明是一个标识作用。</p>
</li>
</ul>
<!-- -->

<ul>
<li><p>  如果注解有成员，在使用注解时，需要指明成员的值。</p>
</li>
<li><p>  自定义注解必须配上注解的信息处理流程(使用反射)才意义。</p>
</li>
</ul>
<p> </p>
<p>|—-Collection接口：单列集合，用来存储一个一个的对象</p>
<p>|—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组</p>
<p>|—-ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</p>
<p>|—-LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</p>
<p>|—-Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</p>
<p>|—-Set接口：存储无序的、不可重复的数据 –&gt;数学概念上的“集合”</p>
<p>|—-HashSet：作为Set接口主要实现类;线程不安全;可以存null值</p>
<p>                |—-LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p>
<p>|—-TreeSet：可以按照添加对象的指定属性，进行排序。</p>
<p> </p>
<p> </p>
<p>|—-Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x)</p>
<p>|—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p>
<p>|—-LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</p>
<p>原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p>
<p>对于频繁的遍历操作，此类执行效率高于HashMap。</p>
<p>|—-TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</p>
<p>底层使用红黑树</p>
<p>|—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p>
<p>|—-Properties:常用来处理配置文件。key和value都是String类型</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.guaguablog.online">GuaGuaSuaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.guaguablog.online/2022/06/26/Java-Notes/">https://www.guaguablog.online/2022/06/26/Java-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.guaguablog.online" target="_blank">GuaGua's BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/images/java.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/16/Vue2-Notes/"><img class="prev-cover" src="/images/vue.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue2 Notes</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/26/C-Notes/"><img class="next-cover" src="/images/c.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C Notes</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GuaGuaSuaka</div><div class="author-info__description">BLOG</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/guaguam"><i class="fab fa-github"></i><span>路远且长</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/guaguam" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1960595339@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/Vue2-Notes/" title="Vue2 Notes"><img src="/images/vue.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue2 Notes"/></a><div class="content"><a class="title" href="/2022/11/16/Vue2-Notes/" title="Vue2 Notes">Vue2 Notes</a><time datetime="2022-11-16T13:16:37.000Z" title="发表于 2022-11-16 21:16:37">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/06/26/Java-Notes/" title="Java Notes"><img src="/images/java.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java Notes"/></a><div class="content"><a class="title" href="/2022/06/26/Java-Notes/" title="Java Notes">Java Notes</a><time datetime="2022-06-26T01:18:00.000Z" title="发表于 2022-06-26 09:18:00">2022-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/26/C-Notes/" title="C Notes"><img src="/images/c.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C Notes"/></a><div class="content"><a class="title" href="/2020/06/26/C-Notes/" title="C Notes">C Notes</a><time datetime="2020-06-26T01:18:00.000Z" title="发表于 2020-06-26 09:18:00">2020-06-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By GuaGuaSuaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.guaguablog.online/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.guaguablog.online/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="15" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>