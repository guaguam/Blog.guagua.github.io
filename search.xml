<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue2 Notes</title>
      <link href="/2022/11/16/Vue2-Notes/"/>
      <url>/2022/11/16/Vue2-Notes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue 介绍<br>什么是 vue ？<br>构建用户界面<br>用 vue 往 html 页面中填充数据，非常的方便<br>框架<br>框架是一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能！<br>要学习 vue，就是在学习 vue 框架中规定的用法！<br>vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库<br>只有把上面老师罗列的内容掌握以后，才有开发 vue 项目的能力！<br>vue 的两个特性<br>数据驱动视图：</p><p>数据的变化会驱动视图自动更新<br>好处：程序员只管把数据维护好，那么页面结构会被 vue 自动渲染出来！<br>双向数据绑定：</p><p>在网页中，form 表单负责采集数据，Ajax 负责提交数据。</p><p>js 数据的变化，会被自动渲染到页面上<br>页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中<br>注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Mode 数据源、View 视图、ViewModel 就是 vue 的实例）</p><p>MVVM<br>MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。</p><p>MVVM 的工作原理<br>ViewModel作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。</p><p>当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构。</p><p>当单元素的值发生变化表时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中</p><p>起步<br>第一个Vue程序：</p><p>导入开发版本的 Vue.js</p><p>创建 Vue实例对象，设置el属性和data属性</p><p>使用简洁的模板语法把数据渲染到页面上</p><p> 双{message}双<br>基本代码与 MVVM 的对应关系</p><p>插件库<br>day.js 快速日期格式化</p><p>解决格式化Vue文件时 逗号、分号问题 ：</p><p>在根目录中，添加一个 .prettierrc.json 配置文件，写入：</p><p>{<br>    “singleQuote”: true,<br>    “semi”: false,<br>    “trailingComma”: “none”<br>}<br>一劳永逸方法：</p><p>在电脑上的用户目录下新建一个 .prettierrc.json 文件，同理上面的参数。</p><p>在 **Vs code **的 setting.json 中添加配置路径：</p><pre><code> 设置 配置文件,解决格式化vue文件时逗号、分号爆红问题 这里注意配置路径，记得使自己计算机上的用户名</code></pre><p>  “prettier.configPath”: “C:/Users/mi/.prettierrc.json”,<br>解决格式化时函数括号前的空格问题 ：</p><p>Prettier 格式化插件无法处理函数括号前添加空格问题<br>解决办法一、在当前项目里的 .eslintrc.js 里 rules 规则里添加忽略加空格爆红提示 ：<br>‘space-before-function-paren’:[‘error’,’never’]<br>解决办法二： 使用 Prettier now 插件可以解决此问题。<br>vue 指令</p><ol><li><p>内容渲染指令<br>v-text 设置标签的内容, 默认写法会 覆盖元素内部原有的内容 , 内部支持写表达式。<br>双{ }双 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！<br>v-html 指令的作用：可以把带有标签的字符串，渲染成真正的 HTML 内容！<br>注意：插值表达式只能用在元素的内容节点中，不能用在元素的属性节点中！</p></li><li><p>v-bind 属性绑定属性<br>在 vue 中，可以使用 v-bind: 指令，为元素的属性动态绑定值；<br>简写是英文的 :<br>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p></li></ol><p>div :title=”‘box’ + index”这是一个 div/div<br>使用 v-bind 在元素绑定时希望内传入 Number数值时，避免被解析成字符串</p><p>select    v-model=’value’<br>    option  ：value=’数字’…/option<br>/select<br>3. v-on 事件绑定属性<br>v-on: 简写是 @</p><p>语法格式为：</p><p>p count的值是： 双{ count }双/p</p><p>button @click=”add”/button</p><p>methods: {<br>   add() {<br>             如果在方法中要修改 data 中的数据，可以通过 this 访问到<br>            this.count += 1<br>   }<br>}<br>$event<br>在事件绑定时，会有一个原生DOM 的事件对象 e，如果事件对象传入参数，默认的事件对象会被覆盖。</p><p>$event 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个 $event。</p><p>例如：</p><p> 点击按钮让count值 递增，绑定点击事件并传参</p><p>button @click=”add(3, $event)”/button</p><p>methods: {<br>   add(n, e) {<br>             如果在方法中要修改 data 中的数据，可以通过 this 访问到<br>            this.count += 1<br>   }<br>}<br>事件修饰符：<br>事件绑定期间非常好玩的一个东西，对事件的触发进行控制。</p><p>.prevent</p><p>a @click.prevent=”xxx”链接/a<br>1<br>.stop</p><p>button @click.stop=”xxx”按钮/button<br>1<br>事件修饰符</p><p>说明</p><p>.prevent</p><p>阻止默认行为 (如：阻止a链接的跳转，阻止表单提交等)</p><p>.stop</p><p>阻止冒泡事件</p><p>.capture</p><p>以捕获模式触发当前的事件处理函数</p><p>.once</p><p>绑定的事件只触发一次</p><p>.self</p><p>只有在event.target 是当前元素自身时触发事件处理函数</p><p>按键修饰符<br>按键</p><p>键码值</p><p>使用</p><p>Enter</p><p>13</p><p>.enter</p><p>Tab</p><p>9</p><p>.tab</p><p>Delete</p><p>46</p><p>.delete (捕获“删除”和“退格”按键)</p><p>Esc</p><p>27</p><p>.esc</p><p>BackSpace</p><p>8</p><p>.space</p><p>Up Arrow</p><p>38</p><p>.up</p><p>Left Arrow</p><p>37</p><p>.left</p><p>Right Arrow</p><p>39</p><p>.right</p><p>Dw Arrow</p><p>40</p><p>.down</p><p>1.自定义其他的按键别名：</p><p>Vue.config.keyCodes.f6 = 118</p><p>input @keyup.f6=”xxx” /   只有单击f6键才会触发xxx的回调<br>2.多个按键一并触发该事件</p><p>@keyup.ctrl.enter=”XXX”     按下ctrl和enter才触发事件执行<br>【案例应用】：表单输入后按回车键添,按esc则清空表单</p><p>input type=”text” v-model=”newbrand”<br>       @keyup.enter=”add”<br>       @keyup.esc=”newbrand=’’” /<br>4. v-model 表单绑定<br>在不操作 DOM 的前提下，实现表单元素和数据的双向绑定。</p><p>v-model 指令的修饰符</p><p>修饰符</p><p>作用</p><p>示例</p><p>.number</p><p>自动将用户输入值转为 Number</p><p>input v-model.number=“age” /</p><p>.trim</p><p>去除首尾空白字符</p><p>input v-model.trim=“msg” /</p><p>.lazy</p><p>表单输入后失去焦点时更新页面数据，而非实时更新</p><p>input v-model.lazy=“msg” /</p><p>input 输入框</p><p>type=“text”</p><p>type=“radio”</p><p>type=“checkbox”</p><p>type=“xxxx”</p><p>textarea</p><p>select</p><ol start="5"><li>条件渲染指令<br>条件渲染指令用来辅助开发者按需控制 DOM 的显示与隐藏。</li></ol><p>v-if 和 v-show<br>v-show 的原理是：动态为元素添加或移除style= “ display: none; “ 样式，从而控制元素的显示与隐藏。</p><p>如果要频繁的切换元素的显示状态，用 v-show 性能会更好。<br>v-if 的原理是：每次动态创建或移除 DOM 元素，实现元素的显示和隐藏。</p><p>如果在运行时条件很少改变，则使用 v-if 较好。<br>v-if 指令在使用的时候，有两种方式：</p><p>直接给定一个布尔值 true 或 false</p><p>p v-if=”true”被 v-if 控制的元素/p<br>给 v-if 提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏</p><p>p v-if=”type === ‘A’”良好/p<br>v-else-if<br>div v-if=”type === ‘A’”优秀/div<br>div v-else-if=”type === ‘B’”良好/div<br>div v-else-if=”type === ‘C’”及格/div<br>div v-else不及格/div<br>6. 列表渲染指令<br>基于一个数组来循环渲染一个列表结构。</p><p>v-for<br>v-for 指令需要使用 item in items 形式的特殊语法</p><p>items 是源数据 (待循环) 的数组，而<br>item 被循环的每一项。<br>【示例】：动态渲染表单数据：</p><p> link rel=”stylesheet” href=”./lib/bootstrap.css”</p><p>   希望 Vue 能够控制下面的这个 div，帮我们把数据填充到 div 内部<br>  div id=”app”<br>    table class=”table table-bordered table-hover table-striped”<br>      thead<br>        th索引/th<br>        thId/th<br>        th姓名/th<br>      /thead<br>      tbody<br>         官方建议：只要用到了 v-for 指令，那么一定要绑定一个 :key 属性<br>         而且，尽量把 id 作为 key 的值<br>         官方对 key 的值类型，是有要求的：字符串或数字类型<br>         key 的值是千万不能重复的，否则会终端报错：Duplicate keys detected<br>        tr v-for=”(item, index) in list” :key=”item.id”<br>          td 双{ index }双/td<br>          td 双{ item.id }双/td<br>          td 双{ item.name }双/td<br>        /tr<br>      /tbody<br>    /table<br>  /div<br>使用 key 维护列表的状态<br>官方推荐, 使用 v-for 指令绑定一个:key 属性，key的作用是为了高效的更新虚拟DOM。</p><p>key 的值类型，是有要求的：字符串或数字类型</p><p>把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）</p><p>改变 data 顺序，index 会重新排序，所以 index 的值不具有唯一性。</p><p>计算属性 computed<br>实时监听 data 中数据的变化，并 return 一个计算后的新值， 供组件渲染 DOM 时使用。</p><p>可以被模板结构 (插值、v-bind ) 或 methods 方法使用。</p><p>但是在某些情况下，我们可能需要对数据进行一些转化后在显示，或者需要将多个数据结合起来进行显示，这时候我们可以使用计算属性。<br>实例 1：</p><p>div id=”app”<br>  h2 双{getFullName()}双/h2<br>  h2 双{fullName}双/h2<br>/div</p><p>  const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>      firstName: ‘lin’,<br>      lastName: ‘willen’<br>    },<br>    computed: {<br>      fullName () {<br>        return this.firstName + ‘ ‘ + this.lastName;<br>      }<br>    },<br>      使用 methods: 每次都会调用方法<br>    methods: {<br>      getFullName () {<br>        return this.firstName + ‘ ‘ + this.lastName;<br>      }<br>    }<br>  })<br>特点：</p><p>定义的时候，要被定义为 “方法”。<br>在使用计算属性的时候，当普通的属性使用即可<br>实现了代码的复用，只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值。<br>实例2：</p><p>div id=”app”<br>  h2总价格： 双{totalPrice}双/h2<br>/div</p><p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>      books:[<br>        {id: 1001, name: ‘Unix编程艺术’,price: 119},<br>        {id: 1002, name: ‘代码大全’,price: 105},<br>        {id: 1003, name: ‘深入理解计算机原理’,price: 99},<br>        {id: 1004, name: ‘现代操作系统’,price: 109}<br>      ]<br>    },<br>    computed: {<br>      totalPrice () {</p><pre><code>    let totalPrice = 0;        for (let i in this.books) &#123;      totalPrice += this.books[i].price;    &#125;           也可以使用 for of     for (let book of this.books) &#123;      totalPrice += book.price;    &#125;    return totalPrice;  &#125;&#125;</code></pre><p>  })<br>计算属性 vs 方法<br>methods和computed看起来都可以实现我们的功能，那么为什么还要多一个计算属性</p><p>methods: 每次使用都会调用方法<br>computed: 计算属性会缓存计算的结果, 不变的情况下只调用一次, 除非原属性发生改变，才会重新调用.<br>计算属性 vs 侦听器<br>侧重的应用场景不同侧重的应用场景不同：</p><p>计算属性侧重于监听多个值的变化，最终计算并返回一个新值。<br>侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值。<br>vue组件<br>什么是组件化开发 ？</p><p>根据封装的思想，把页面上可重用的 UI 结构封装为组件，方便项目的开发和维护。</p><p>vue 中的组件化开发</p><p>vue 是一个支持组件化开发的前端框架。<br>vue 中组件的后缀名是.vue<br>组件的构成<br>每个 .vue 组件都由 3 部分构成，分别是：</p><p>template ：组件的模板结构，且每个组件中必须包含template模板结构。</p><p>script ： 组件的 JavaScript 行为</p><p>style ：组件的样式</p><p> 标签上添加 lang=“less” 属性，即可使用 less 语法编写组件的样式<br> scoped 防止样式冲突</p><p>script 节点：<br>（1）script 中的 name 节点</p><p>用来定义组件的名称，调试的时候可以清晰的区分每个组件。<br>（2）script 中的 data 节点</p><p>组件渲染期间需要用到的数据， data 必须是函数, 不能直接指向对象数据。<br>（3）script 中的 methods 节点</p><p>组件中的事件处理函数（方法），必须定义到 methods 节点中<br>注册私有组件<br>通过 components 注册的是私有子组件，被注册的组件只能用在当前组件中。</p><p>1.使用 import 语法导入需要的组件</p><p>import Left from ‘@/components/Left.vue’<br>2.在 script 标签中使用 components 节点注册组件</p><p>script<br>export default {<br>  comments:{<br>    Left<br>  }<br>}<br>/script<br>3.以标签的形式使用刚才注册的组件</p><p>template<br>   Left/Left<br>/template<br>注册全局组件<br>在 vue 项目的 main.js 入口文件中，通过 Vue.component()方法，可以注册全局组件。</p><p>注册：</p><p>import Vue from ‘vue’<br>import App from ‘./App.vue’</p><p> 导入需要被全局注册的那个组件<br>import Count from ‘@/components/Count.vue’</p><p> 参数一： 组件的 ‘注册名称’，将来以标签形式使用时要求和这个名称一样。<br> 参数二： 需要被全局注册的那个组件。<br>Vue.component(‘MyCount’, Count)</p><p> 消息提示的环境配置，设置为开发环境或者生产环境<br>Vue.config.productionTip = false</p><p>new Vue({<br>   render 函数中，渲染的是哪个 .vue 组件，那么这个组件就叫做 “根组件”<br>  render: h = h(App)<br>}).$mount(‘#app’)<br>使用：</p><p>template<br>     这里需要注意 ‘注册名称’<br>    MyCount /MyCount<br>/template<br>组件注册时名称的大小写<br>在 Vue 定义组件注册名称的方式有两种：</p><p>短横线命名法，例如 my-swiper 和 my-search<br>使用组件时也必须使用短横线命名<br>大驼峰命名法，例如 MySwiper 和 MySearch<br>既可以按照大驼峰命名法使用，也可以转化为短横线名称进行使用。<br>注意： 在开发中，推荐使用大驼峰命名法为组件注册名称，因为它的适用性更强。</p><p>组件之间的样式冲突问题<br>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。</p><p>scoped 属性<br>让当前组件的样式对其子组件是不生效。</p><p>Vue 中提供了在style 节点添加 scoped属性，来防止样式冲突问题：</p><p>原理是为每个组件分配唯一的自定义属性，在编写组件样式时，通过属性选择器来控制样式的作用域。</p><p>template<br>    div class=”container” data-v-001<br>        h3 data-v-001  轮播图组件件/h3<br>    /div<br>/template</p><p>style<br>   通过中括号’属性选择器’，防止样式冲突问题<br>   因为每个组件分配的自定义属性是’唯一的’<br> . container[data-v-001]{<br>      border: 1px solid red;<br>    }<br>/style<br>为了提高开发效率和开发体验，直接在 style 节点使用 scoped 属性：</p><p>style lang=”less” scoped<br>/style<br>/deep/ 样式穿透<br>让某些样 式对子组件生效。</p><p>使用场景： 当使用第三方组件库的时候，需要修改第三方组件默认样式的时候。</p><p>style lang=”less” scoped</p><p>不加 /deep/ 时，生成的选择器格式为 .title[data-v-052242de]*/<br>.title{<br>    color: blue;<br>}</p><p>加/deep/ 时，生成的选择器格式为 [data-v-052242de] .title*/<br>/deep/ .title {<br>  color: pink;<br>}<br>/style<br>Class 与 Style 绑定<br>通过 v-bind动态操作元素样式。</p><ol><li>动态绑定 HTML 的 class：<br>通过三元表达式，动态的为元素绑定 class 的类名：</li></ol><p>h3 class=”thin” :class=”isItalic ?’italic’:’’”MyDeep 组件/h3<br>button @click=”isItalic=!lisItalic” Toggle Italic /button</p><p>data(){<br>    return { isItalic:true }<br>.thin{<br>    font-weight:200;<br>.italic{<br>    font-style:italic;<br>}<br>2. 以数组语法绑定 HTML 的 class<br>如果元素需要动态绑定多个 class 的类名，此时可以使用数组的语法格式</p><p>h3 class=”thin”:class=”[isItalic? ‘italic’: ‘’,isDelete? ‘delete’:’’]”MyDeep组件/h3<br>button @click=”isItalic= !isItalic” 字体变细 /button<br>button @click=”isDelete= !isDelete” 添加删除线 e/button</p><p>script<br>export default {<br>  data () {<br>    return {<br>      isItalic: true,<br>      isDelete: false,<br>    }<br>  }<br>}<br>/script<br>3. 以对象语法绑定 HTML 的 class：<br>h3 class=”thin”:class=”classObj”MyDeep组件/h3<br>button @click=”classObj.isItalic = !classObjisItalic” 字体变细 /button<br>button @click=”classObj.isDelete = !classObj.isDelete” 添加删除线 e/button</p><p>script<br>export default {<br>  data () {<br>    return {<br>        classObj:{<br>            isItalic: true,<br>              isDelete: false,<br>        }<br>    }<br>  }<br>}<br>/script<br>4. 以对象语法绑定内联的 style<br>命名可以用驼峰式或短横线分隔 (记得用引号括起来) 来命名：</p><p>div :style=”{color:active, fontSize: fsize +’px’,’background-color’: bgcolor}”<br>    Hello world!!<br>/div</p><p>button @click=”fsize += 1”字号+1/button<br>button @click=”fsize -= 1”字号-1/button</p><p>data () {<br>    return {<br>      active: ‘red’,<br>      fsize: 30,<br>      bgcolor: ‘pink’<br>    }<br>}<br>自定义属性 props<br>props是组件的自定义属性，允许使用者通过自定义属性，为当前组件指定初始值，极大的提高组件的复用性。</p><p>在组件中声明 prpos<br>my-article 组件的定义如下：</p><p>template<br>h3标题： 双{title}双/h3<br>h5作者： 双{author}双/h5<br>/template<br>父组件传递给my-article组件的数据，必须在props节点中声明 :</p><p>script<br>    export default {<br>        props:[‘title’,’author’],<br>/script<br>无法使用未声明的 props<br>如果父组件给子组件传递了未声明的 props 属性，则这些属性会被忽略，无法被子组件使用。</p><p>动态绑定 props 的值<br>使用 v-bind 属性绑定的形式，可以为组件动态绑定 props 的值。</p><p>！–通过V-bind属性绑定，为author动态赋予一个表达式的值</p><p>my-article :title=”info.title” :author=”‘post by’+info.author”/my-article<br>props 的大小写命名<br>组件中如果使用“camelCase (驼峰命名法)”声明了 props 属性的名称，则有两种方式为其绑定属性的值：</p><p>script<br>    export default {<br>        props:[‘pubTime’],   使用’驼峰命名’法为当前组件声明 pubTime 属性<br>/script<br>使用时既可以用驼峰命名，亦可以用短横线分隔命名的形式为组件绑定属性的值 ：</p><p>my-article pubTime=”2021” /my-article<br> 等价于<br>my-article pub-time=”2021” /my-article<br>props 验证<br>基础的类型检查 type</p><p>props:{</p><p>   支持的8种基础类型</p><p>   propA:String,    字符串类型<br>   propB:Number,    数字类型<br>   propC:Boolean,   布尔值类型<br>   propD:Array,     数组类型<br>   propE:Object,    对象类型<br>   propF:Date,      日期类型<br>   propG:Function,  函数类型<br>   propH:Symbol     符号类型</p><p>  }<br>多个可能的类型</p><p>必填项校验 required</p><p>属性默认值 default</p><p>props:{<br>     通过数组形式，为当前属性定义多个可能的类型<br>    type: [String, Number],<br>    required: true,<br>    default: 0,<br>}</p><p>自定义验证函数<br>在封装组件时，可以为 prop 属性指定自定义的验证函数，从而对 prop 属性的值进行更加精确的控制：</p><p> props:{<br>   type:{<br>        通过 validataor函数，对type 属性进行校验，属性值 通过val形参接收<br>     validataor(val){<br>        必须匹配下列字符串中的一个<br>       return [‘success’,’warning’,’danger’].indexOf(val) !== -1<br>     }<br>   }<br>}</p><p>prpos 传入不同的初始值<br>在实际开发中我们经常会碰到下面的情况：</p><p>在不同组件使用同一个注册的组件时候希望赋值一个不同的初始值。<br>1.组件的封装者通过 props 允许使用者自定义初始值：</p><p>template<br>  div<br>    h5Count是全局组件，将被Left 和 Right组件使用/h5<br>    pcount 的值是： 双{ init }双/p<br>    button @click=”count += 1”+1/button<br>  /div<br>/template</p><p>script<br>export default {<br>   props: [‘init’],<br>  props: {<br>     自定义属性的名字，是封装者自定义的（只要名称合法即可）<br>    init: {<br>       如果外界使用 Count 组件的时候，没有传递 init 属性，则默认值生效<br>      default: 0,<br>       指定值类型必须是 Number 数字<br>      type: Number,<br>       必填项校验(表示必须传入值)<br>      required: true<br>    }<br>  },</p><p>  data() {<br>    return {<br>        props是只读的且不可修改<br>        要想修改 props 的值，可以把 props 的值转存到 data中<br>      count: this.init<br>    }<br>  }<br>}</p><p>2.组件的使用者通过属性节点传入初始值</p><p>Left 组件、Right 组件：</p><p>template<br>  div class=”left-container”<br>    h3Left 组件/h3<br>    hr /<br>    MyCount :init=”9”/MyCount<br>  /div<br>/template</p><p>template<br>  div class=”right-container”<br>    h3Right 组件/h3<br>    hr /</p><pre><code>MyCount :init=&quot;6&quot;/MyCount</code></pre><p>  /div<br>/template</p><p>props 里传参注意点<br>props 可以通过[]给数据定义多个可能的数据类型 ;</p><p>props 传入 Object 默认值必须是一个 fn</p><p>props: {<br>commCount: {<br>type: String,<br>default: ‘’<br>},<br>pubdate: {<br> 通过数组形式，为当前属性定义多个可能的类型<br>type: [String, Number],<br>default: ‘’<br>},<br>cover: {<br>type: Object,<br> 通过 default 函数，返回 cover 的默认值<br>default: function() {<br> 这个 return 的对象就是 cover 属性的默认值<br>return { cover: 0 }<br>}<br>}<br>}</p><p>props 是只读的,想修改 props 的值，可以把 props 的值转存到 data 中。<br>props 的三个属性值：default、type、required。<br>自定义事件<br>封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件。</p><p>vue2 中自定义事件的 3 个使用步骤：</p><p>在封装组件时 （子组件）：触发自定义事件</p><p>在使用组件（父组件）时：监听自定义事件</p><p>触发自定义事件<br> 子组件</p><p>button @click=”onBtnClick” +1 /button</p><p>script<br>export default {<br>    data() {<br>         子组件自己的数据，将来希望把 count 值传给父组件<br>        return { count: 0 }<br>    },<br>    methods: {<br>        onBtnClick() {<br>            this.count t= 1<br>            修改数据时，通过 $emit()触发自定义事件<br>             当点击 ‘+1’ 按钮时 调用this.$emit 触发自定义的 numchange 事件<br>            this.$emit( ‘numchange’)}<br>    }<br>}<br>/script<br>监听自定义事件<br> 父组件<br>Son @numchange=”getNewCount”/Son</p><p>methods : {<br>    getNewCount(val) {<br>    console.log(‘监听到了 count 值的变化’, val)<br>}，</p><p>自定义事件传参<br>在调用 this.$emit() 方法触发自定义事件时，可以通过第 2 个参数为自定义事件传参:</p><p>methods: {<br>    onBtnClick() {<br>        this.count t= 1<br>        this.$emit( ‘numchange’ , this.count)}  触发自定义事件,通过第二个参数传参<br>}</p><p>filter 过滤器<br>在 vue 3.x 的版本中剔除了过滤器相关的功能。</p><p>在 vue 3.x 使用计算属性或方法代替被剔除的过滤器功能。</p><p>过滤器（Filters）常用于文本的格式化。过滤器可以用在两个地方：双括号插值表达式 和v-bind属性绑定。</p><p> 在双花括号中通过 | 调用capitalize过滤器，对message值进行格式化<br> 双{ message | capitalize }双</p><p> 在 <code>v-bind</code> 中<br>div v-bind:id=”rawId | formatId”/div<br>私有过滤器<br>在 filters 节点下定义的过滤器，称为“私有过滤器”，因为它只能在当前 vm 实例所控制的 el 区域内使用。</p><p>创建一个私有过滤器，示例代码如下：</p><p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        message: ‘hello world!’,<br>        info: ‘title info’<br>    },<br>     在 filters 节点下定义过滤器<br>    filters: {<br>         把首字母转换为大写的过滤器<br>        capitalize (value) {<br>            return value.charAt(0).toUpperCase() + value.slice(1)<br>        }<br>    }<br>全局过滤器<br>如果希望在多个 vue 实例之间共享过滤器，则可以按照如下的格式定义全局过滤器:</p><p> Vue.filters()方法接收两个参数：<br> 第一个参数：过滤器名字   第二个参数：过滤器的处理函数</p><p>Vue.filter(‘capitalize’,(str)={<br>    return value.charAt(0).toUpperCase() + value.slice(1)’<br>} )<br>调用多个过滤器：<br> 双{ message | filterA | filterB }双<br>1<br>先把 message 的值交给 filterA 处理，再把 filterA 处理结果交给 filterB 进行处理，最终把 filterB 的处理结果，作为最终值渲染到页面上。<br>过滤器传参<br>过滤器是 JavaScript 函数，因此可以接收参数：</p><p> 双{ message | filterA(‘arg1’, arg2) }双</p><p> 第一个参数永远是 ‘管道符’ 前面待处理的值，第二个参数开始才是调用过滤器时传递的参数</p><p>Vue.filter(‘filterA’,(msg,arg1,arg2)={<br>     过滤器的逻辑代码<br>})<br>这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 ‘arg1’ 作为第二个参数，表达式 arg2 的值作为第三个参数。</p><p>p 双{message | cap | maxl(5)}双/p</p><p>Vue.filter(‘cap’, (str) = {<br>    return str.charAt(0).toUpperCase() + str.slice(1) + ‘—-‘<br>})</p><p>Vue.filter(‘maxl’, (str, len = 10) = {<br>    if (str.length = len) return str<br>    return str.slice(0, len) + ‘….’<br>})<br>var app = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        message: ‘hello Vue 2021年10月30日00:07:45!’<br>    }</p><p>过滤器的注意点<br>在过滤器函数中，一定要有 return 值<br>在过滤器的形参中，可以获取到“管道符”前面待处理的那个值<br>如果全局过滤器和私有过滤器名字一致，此时按照“就近原则”，调用的是”私有过滤器“<br>label的for属性<br>使用lable自带的属性进行单选钮的启用和禁用：</p><p>input type=”checkbox” :id=”‘cb’ + item.id” v-model=”item.status”<br>label  :for=”‘cb’ + item.id” v-if=”item.status”已启用/label<br>label  :for=”‘cb’ + item.id” v-else已禁用/label<br>watch 侦听器<br>watch 侦听器 监视数据的变化，从而针对数据的变化做特定的操作。</p><p>侦听器的格式<br>方法格式的侦听器<br>无法在刚进入页面的时候，自动触发！！<br>如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器！<br>对象格式的侦听器<br>可以通过 immediate 选项，让侦听器自动触发！<br>可以通过 deep 选项，让侦听器深度监听对象中每个属性的变化！<br>使用方法格式创建的侦听器：</p><p>监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用：</p><p>import axios from ‘axios’</p><p>export default{<br>    data(){<br>        return{ username: ‘’}<br>    }<br>},<br>watch: {<br>     newVal 是’变化后的新值’，oldVal 是’变化之前的旧值’<br>    async username(newVal,oldVal) {<br>        if (newVal === ‘’) return<br>         使用 axios 发起请求，判断用户名是否可用<br>        const { data: res } = await axios.get(<code>https:www.escook.cn/api/finduser/$&#123;newVal&#125;</code> )<br>        console.log(res)<br>    }<br>}</p><p>使用方法创建时：组件在初次加载完毕后不会调用 watch 侦听器。</p><p>immediate 选项<br>如果想让 watch 侦听器在浏览器打开时立即被调用，则需要使 用 immediate 选项。</p><p>使用对象格式创建的侦听器：</p><p>watch: {<br>    username: {<br>         handler 是固定写法，表示当 username 的值变化时，自动调用 handler 处理函数<br>        async handler(newVal,oldVal) {<br>            if (newVal === ‘’) return<br>            const { data: res } = await axios.get(‘https:<a href="http://www.escook.cn/api/finduser/&#39;">www.escook.cn/api/finduser/&#39;</a> + newVal)<br>            console.log(res)<br>        },<br>             表示页面初次渲染好之后，就立即触发当前的 watch 侦听器<br>            immediate: true<br>    }<br>}<br>使用 handler 定义侦听器函数<br>immediate控制侦听器是否自动触发， 默认值为 false不立即触发。<br>deep 选项<br>如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 开启 深度监听。</p><p>input type=”text” v-model.trim=”username”/</p><p>data: {<br>   info: {username: ‘admin’}<br>},<br>watch:{<br>     监听info对象的变化<br>    info:{<br>          handler(newVal){<br>            console.log(newVal.username)<br>        },<br>     开启深度监听，监听每个属性值的变化，默认值为 false<br>    deep: true<br>    }<br>}<br>监听对象单个属性的变化<br>如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器。</p><p>const vm = new Vue({<br>    el: ‘#app’,<br>    data: {<br>        info: {username: ‘admin’,}<br>    },<br>    watch:{<br>        ‘info.username’:{<br>            handler(newVal){<br>                console.log(newVal)<br>            },<br>        }<br>    }<br>})<br>组件的生命周期<br>生命周期（Life Cycle）是指一个组件从创建 - 运行 - 销毁的整个阶段，强调的是一个时间段。<br>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。<br>生命周期强调的是时间段，生命周期函数强调的是时间点。</p><p>生命周期函数的分类<br>生命周期图示:</p><p>需要注意的三个周期函数：</p><p>在实际开发中，created 是最常用的生命周期函数 ！</p><p>组件之间的数据共享</p><p>父→子<br>父组件通过 v-bind 属性绑定向子组件共享数据，子组件使用 props接收数据。</p><p> 父组件<br> 注册子组件<br>Son :msg=”message” :user=”userinfo”/Son</p><p>script<br>     导入子组件<br>    import Son from ‘@component/Son.vue’</p><p>export default {<br>    data:{<br>        return{<br>        message:’hello vue.js’<br>        userinfo:{<br>        name: ‘lilei’,age: 21<br>    },<br>    components: {<br>        Son<br>            }<br>        }<br>    }<br>}<br>/script</p><p> 子组件<br>template<br>    div<br>        h5Son组件/h5<br>        p父组件传递过来的 msg值是:  双{ msg }/p<br>        p父组件传递过来的user值是:  双{ user }双/p<br>    /div<br>/template</p><p>export default {<br>    props: [ ‘msg’ , ‘user ‘]<br>}<br>子 → 父<br>子组件向父组件共享数据使用自定义事件。</p><p> 子组件</p><p>export default {<br>    data() {<br>         子组件自己的数据，将来希望把 count 值传给父组件<br>        return { count: 0 }<br>    },<br>    methods: {<br>        add() {<br>            this.count t= 1<br>            修改数据时，通过 $emit()触发自定义事件<br>            this.$emit( ‘numchange’ , this.count)}<br>    }<br>}</p><p> 父组件<br>h1App 根组件/h1<br>h3子组件传过来的数据是 ：  双{ countFromSon }双/h3<br>Son @numchange=”getNewCount” /Son</p><p>script<br>import Son from ‘@component/Son.vue’</p><p>export default {<br>    data() {<br>        return { countFromSon: 0 }<br>    },<br>    methods : {<br>        getNewCount(val) {<br>            console.log(‘numchange 事件被触发了！’, val)<br>            this.countFromSon = val<br>        }，<br>        components: {<br>        Son<br>    }<br>}<br>}<br>    /script</p><p>兄弟组件数据共享<br>在 vue2.x 中，兄弟组件之间数据共享的方案是 EventBus。</p><p>EventBus 的使用步骤</p><p>创建 eventBus.js模块，并向外共享一个 Vue 的实例对象<br>在数据发送方，调用 bus.$emit(‘事件名称’, 要发送的数据)方法触发自定义事件 。<br>在数据接收方，调用 bus.$on(‘事件名称’, 事件处理函数)方法注册一个自定义事件。<br>ref 引用 操作DOM<br>不依赖于 jQuery 和调用 DOM API 的情况下，获取 DOM 元素或组件的引用。</p><p>每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下，组件的 $refs 指向一个空对象。</p><p>使用 ref 引用 DOM 元素<br>！–使用ref属性，为对应的DOM添加引用名称 </p><p>h3 ref=”myh3”MyRef 组件/h3<br>button@click=”getRef”获取$refs 引用/button</p><p>methods:{<br>    getRef(){<br>        通过this.$refs.引用的名称可以获取到DOM元素的引用<br>        console.log(this.$refs.myh3)<br>        操作DOM元素，把文本颜色改为红色<br>        this.$refs.myh3.style.color=’red’<br>}，<br>使用 ref 引用组件实例<br>需求： 在根组件控制子组件</p><p>！–使用ref属性，为对应的“组件”添加引用名称 </p><p>my-counter ref=”counterRef” /my-counter<br>button @click=”getRef” 获取$refs 引用 /button</p><p>methods:{<br>    getRef（）{<br>         通过this.$refs.引用的名称可以引用组件的实例<br>        console.log（this.$refs.counterRef）<br>         引用到组件的实例之后，就可以调用 子组件上的 methods 方法<br>        this.$refs.counterRef.add（）<br>}，<br>点击文本框自动获得焦点<br>添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。</p><p>this.$nextTick(cb) 方法<br>$nextTick(cb)保证 cb 回调函数可以操作到最新的 DOM 元素（推迟到下一个 DOM 更新周期之后执行）。</p><p>解决我们在页面没有渲染完成前使用 ref 操作DOM元素报错问题。<br>控制文本框和按钮的按需切换<br>点击按钮展示文本框，文本框输入时隐藏按钮：</p><p>template<br>    input type=”text” v-if=”inputVisible” ref=”ipt”<br>    button v-else @click=”showInput”展示input输入框/button<br>/template</p><p>script<br>export default{<br>    data(){<br>        return{<br>        控制文本框和按钮的按需切换<br>        inputVisible:false，<br>}，<br>methods:{<br>    showInput(){<br>        切换布尔值，显示文本框<br>        this.inputVisible=true</p><pre><code>    获取文本框的DOM引用，并调用.focus（）使其自动获得焦点         this.$refs.ipt.focus（） 错误，此时页面未渲染完毕，无法获取文本框        把对input文本框的操作，推迟到下次DOM更新之后。否则页面上根本不存在文本框元素    this.$nextTick(() =&#123;            this.$refs.ipt.focus（）    &#125;）&#125;</code></pre><p>}，<br>    /script<br>动态组件<br>实现不同组件之间的按需展示。( 动态切换组件显示和隐藏 ) ，类似于 Vue-Router。</p><p>动态组件的基本使用<br>Vue 提供了一个内置的 component组件，专门用来实现动态组件的渲染 :</p><p>component 标签是 vue 内置的，作用：组件的占位符</p><p>通过 :is 属性，动态指定要渲染的组件</p><p>is 属性的值，表示要渲染的组件的名字。</p><p>is 属性的值，应该是组件在 components 节点下的注册名称。</p><p>使用 keep-alive保持组件的状态 （避免组件切换时重新渲染）。</p><p>keep-alive 会把内部的组件进行缓存，而不是销毁组件。<br>通过 include 指定哪些组件需要被缓存。</p><p>通过 exclude属性指定哪些组件不需要被缓存。</p><p> 点击按钮，动态切换组件的名称</p><p>button @click=“comName = ‘Left’”展示 Left<br>button @click=“comName = ‘Right’”展示 Right</p><p>在组件中定义 name 名称：<br>当提供了 name 属性之后，组件的名称就是 name 属性的值。</p><p>export default {<br>name: ‘MyRight’<br>}</p><p>声明 name 应用场景：结合keep-alive标签实现组件缓存功能；以及在调试工具中看到组件的 name 名称。</p><p>插槽 slot<br>在签形式使用的组件中内容节点中插入内容。</p><p>通过 slot 元素 定义插槽，从而为用户预留内容占位符。<br>封装组件时，没有预留插槽的内容会被丢弃。<br>后备内容<br>在 slot 标签内添加的内容会被作为后备内容。</p><p> 子组件 my-com<br>template<br>    slot这是后备内容/slot<br>/template</p><p> 使用插槽<br>    my-com<br>        如果用户没有提供内容，上面 slot标签 内定义的内容会生效，此时页面会有 “这是后备内容”<br>        如过提供了，下面的 img 将会被渲染到页面上<br>        img src=”../assets/log.png” alt=””<br>    /my-com<br>具名插槽<br> MyArticle 组件<br>template<br>div class=”container”<br>    header<br>        slot name=”header”/slot<br>    /header<br>    main<br>        slot/slot<br>    /main<br>    footer<br>        slot name=”footer”/slot<br>    /footer<br>    /div<br>/template<br>Vue 官方规定，每个 slot插槽，都要有一个 name名称，一个不带 name 的 slot 出口会带有隐含的名字“default”。<br>为具名插槽提供内容<br>如果要把内容填充到指定名称的插槽中，我们可以在一个 template 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称：</p><p>MyArticle</p><pre><code>template v-slot:header     把内容放在 MyArticle组件的 header 标签内    h1如今最好，没有来日方长。/h1/template 上一个代码块中，main 标签未指定具名插槽，所以默认渲染到 main标签中p现在是2021年11月7日 22点05分 星期天/pp今天不仅是周日，也是冬至/ptemplate #footer       p最后，祝大家冬至快乐！/p/template</code></pre><p>/MyArticle<br>v-slot:可以简写 #。例如 v-slot:header 可以被重写为 #header。</p><p>v-slot 属性只能放在 组件标签和 template 元素上 (否则会报错)。</p><p>作用域插槽<br>在封装组件的过程中，可以为预留的slot插槽绑定 props 数据，这种带有 props 数据的slot 叫做“作用域插槽”。示例代码如下：</p><p>template<br>    div<br>        h1 这是 Left 组件/h1<br>        ！–下面的slot 是一个作用域插槽<br>         slot v-for=”item in list” :user=”item”/slot<br>    /div<br>  /template<br>接收作用域插槽对外提供的数据, 使用解构赋值简化数据的接收过程 :</p><p>！– 使用自定义组件<br>Left<br>  ！–作用域插槽对外提供的数据对象，可以通过“解构赋值”简化接收的过程<br>  template #default=”{user}”<br>        tr<br>            td 双{user.id}双/td<br>            td 双{user.name}双/td<br>            td 双{user.state}双/td<br>        /tr<br>  /template<br>/Left<br>自定义指令<br>vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令。</p><p>私有自定义指令 directives: { }<br>在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令。</p><ol><li>定义一个私有自定义指令：<br>directives:{<br> color:{<pre><code> 为绑定到的HTML元素设置红色的文字 bind(el)&#123;     形参中的el是绑定了此指令的、原生的DOM对象     el.style.color=‘red&#39; &#125;</code></pre></li><li>使用自定义指令：<br>使用自定义指令时，需要加上v-指令前缀</li></ol><p>！–声明自定义指令时，指令的名字是color 使用时就是 v-color  </p><p>App组件<br>3. 为自定义指令动态绑定参数值<br>在 template 结构中使用自定义指令时，可以通过等号 = 的方式，为当前指令动态绑定参数值：</p><p>template</p><p>！–在使用指令时，动态为当前指令绑定参数值 color<br>h1 v-color=”color”App组件/h1</p><p>/template</p><p>data(){<br>    return{<br>    color:’red’<br>}<br>4. 通过 binding 获取指令的参数值：<br>在上面的实例中我们为自定义指令绑定了一个动态的参数值，如何拿到这个值呢 ？</p><p>在声明自定义指令时，可以通过形参中的第二个参数，来接收指令的参数值</p><p>h1 v-color=”color”App组件/h1</p><p> 此时传入的是字符串，不会在data 数据中查找<br>p v-color=”‘blue’” /p</p><p>directives:{<br>    color:{<br>        bind(el，binding){<br>            通过binding对象的.value属性，获取动态的参数值<br>            el.style.color=binding.value<br>}<br>5. 使用 update 函数更新 DOM<br>update 函数会在每次 DOM 更新时被调用。</p><p>注意：在 vue3 的项目中使用自定义指令时， bind 必须改为 mounted 、 update 改为 updated 。</p><p>bind 函数只调用 1 次：当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。</p><p>directives:{<br>    color:{<br>        当指令第一次被绑定到元素时被调用<br>        bind(el，binding){<br>            el.style.color=binding.value<br>    }，<br>        每次DOM更新时被调用<br>        update(el，binding){<br>            el.style.color=binding.value<br>    }<br>10<br>6. 同时使用 bind 和 update 函数简写<br>如果 bind 和 update 函数中的 逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：</p><p>directives:{<br>    在 bind 和 update 时，会触发相同的业务逻辑<br>    color( el，binding ){<br>        el.style.color=binding.value<br>}<br>全局自定义指令 Vue.directive ()<br>通过“ Vue.directive()” 进行声明 。</p><p>注意：在使用 Vue-cli ( 脚手架) 时，要把全局自定义指令写在main.js文件中：</p><p>参数1：字符串，表示全局自定义指令的名字<br>参数2：对象，用来接收指令的参数值</p><p>Vue.directive(‘color’，function(el，binding){<br>        el.style.color=binding.value<br>})</p><p> 简写<br>Vue.directive（’color’，(el，binding) ={<br>        el.style.color=binding.value<br>})<br>vue-cli<br>Vue CLI 是官方发布的vue.js项目脚手架, 可以快速搭建vue开发环境以及Webpack配置。</p><p>安装和使用<br>一、安装Vue脚手架</p><p>npm install -g @vue/cli<br>1<br>二、创建项目</p><p>vue create project(项目名称)<br>1<br>目录详解：</p><p>|- public          静态页面目录<br>    |- index.html  项目入口<br>|- src             源码目录<br>    |- assets      存放项目中用到的静态资源文件，例如：css 样式表、图片资源<br>    |- components      封装的、可复用的组件，都要放到 components 目录下<br>    |- App.vue         根组件<br>    |- main.js         项目的入口文件。整个项目的运行，要先执行<br>vue 项目的运行流程：</p><p>通过 main.js把 App.vue渲染到index.html的指定区域中。</p><p>App.vue 用来编写待渲染的模板结构<br>index.html 中需要预留一个 el 区域<br>main.js 把 App.vue 渲染到了 index.html 所预留的区域中<br>axios<br>axios 是一个专注于网络请求的库， 调用 axios 方法得到的返回值是 Promise 对象。</p><p>axios 的基本使用<br>发起 GET 请求：</p><p>axios({<br>   请求方式<br>  method: ‘GET’,<br>   请求的地址<br>  url: ‘http:<a href="http://www.liulongbin.top:3006/api/getbooks&#39;">www.liulongbin.top:3006/api/getbooks&#39;</a>,</p><p>   URL 中的查询参数（GET请求传参）<br>  params: {<br>    id: 1<br>  }<br>}).then(function (result) {<br>  console.log(result)<br>})<br>params 表示传递到服务器端的数据，以url参数的形式拼接在请求地址后面<br>如 ： params: { page:1,per:3 }<br>最终生成：http:jsonplaceholder.typicode.com/page=1&amp;per=3<br>发起 POST 请求：</p><p>document.querySelector(‘#btnPost’).addEventListener(‘click’, async function () {</p><p>   如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！<br>   await 只能用在被 async “修饰”的方法中</p><ol><li>调用 axios 之后，使用 async/await 进行简化</li><li>使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来</li><li>把解构出来的data属性，使用冒号进行重命名，一般都重命名为 { data: res }</li></ol><p>  const { data: res } = await axios({<br>    method: ‘POST’,<br>    url: ‘http:<a href="http://www.liulongbin.top:3006/api/post&#39;">www.liulongbin.top:3006/api/post&#39;</a>,</p><pre><code>  POST请求体传参data: &#123;  name: &#39;zs&#39;,  age: 20&#125;</code></pre><p>  })</p><p>  console.log(res)<br>})</p><p>axios 封装的 6 个属性：</p><p>axios 在请求到数据之后，在真正的数据之外，套了一层外壳。</p><p>{<br>    config:{ },<br>     data 才是服务器返回的真实数据<br>    data:{<br>        status: 200,<br>        msg: “获取数据成功！”,<br>        data: Array(6)<br>    },<br>    headers:{ … },<br>    request:{ },<br>    status: 200,<br>    statusText: ‘OK’,<br>}<br>axios直接发起GET和POST请求<br>document.querySelector(‘#btnGET’).addEventListener(‘click’, async function () {<br>     axios.get(‘url地址’, {<br>         GET 参数<br>        params: {}<br>      }) */</p><pre><code>const &#123; data: res &#125; = await axios.get(&#39;http:www.liulongbin.top:3006/api/getbooks&#39;, &#123;    params: &#123; id: 1 &#125;&#125;)console.log(res)</code></pre><p>})</p><p>document.querySelector(‘#btnPOST’).addEventListener(‘click’, async function () {<br>     axios.post(‘url’, {  POST 请求体数据 */ })<br>    const { data: res } = await axios.post(‘http:<a href="http://www.liulongbin.top:3006/api/post&#39;">www.liulongbin.top:3006/api/post&#39;</a>, { name: ‘zs’, gender: ‘女’ })<br>    console.log(res)<br>})<br>17<br>在 Vue-cli 中使用 axios<br>一般我们会直接这么用：</p><p> 在组件内<br>template<br>    button @click=”postInfo”发起 POST 请求/button<br>/template</p><p>script</p><ol><li>导入 axios<br>import axios from ‘axios’<br>export default {</li><li>在 methods 定义 axios请求方法<br>methods: {<br>async postInfo() {<br>  const { data: res } = await axios.post(‘http:<a href="http://www.liaoyia.top:3306/api/post&#39;">www.liaoyia.top:3306/api/post&#39;</a>, { name: ‘zs’, age: 20 })<br>  console.log(res)<br>}<br>}<br>}<br>/script<br>缺点： 在每次使用时候都要导入 axios 文件，写请求地址 (对后期维护不友好) 。</li></ol><p>把 axios 挂载到 Vue原型上并配置请求根路径<br>避免重复导入axios 和重复写入完整请求地址。</p><p>在main.js中配置</p><p>import Vue from ‘vue’<br>import App from ‘./App.vue’<br>import axios from ‘axios’</p><p>Vue.config.productionTip = false</p><p> 全局配置 axios 的请求根路径 (官方提供配置项)<br>axios.defaults.baseURL = ‘http:<a href="http://www.liaoyia.top:3006&#39;">www.liaoyia.top:3006&#39;</a></p><p> 把 axios 挂载到 Vue.prototype 上，供每个 .vue 组件的实例直接使用<br>Vue.prototype.$http = axios</p><p> 今后，在每个 .vue 组件中要发起请求，直接调用 this.$http.xxx<br> 但是，把 axios 挂载到 Vue 原型上，有一个缺点：不利于 API 接口的复用！！！</p><p>new Vue({<br>  render: h = h(App)<br>}).$mount(‘#app’)</p><p>使用：</p><p>template<br>     button @click=”btnGetBooks”获取图书列表的数据/button<br>/template</p><p>script<br>export default {<br>  methods: {<br>     点击按钮，获取图书列表的数据<br>    async btnGetBooks() {<br>      const { data: res } = await this.$http.get(‘/api/getbooks’)<br>      console.log(res)<br>    }<br>  }<br>}<br>/script<br>但是把 axios 挂载到 Vue原型上并配置请求根路径也有缺点：</p><p>无法实现API接口的复用 : 在多个组件想使用同一个请求方法(API)的时候，只能在每个组件重新定义一次。</p><p>axios 封装<br>1.如果项目中有多个请求地址，我们可以根据多个地址使用工厂模式封装 js 模块，创建多个 axios 实例对象，并设置请求根路径 (baseURL) ：</p><p>步骤如下： 在项目的 src目录下创建utils文件夹并新建一个 request.js文件：</p><p>import axiox from ‘axios’</p><p>const request =axiox.create({<br>    baseURL会在发送请求的时候拼接在url参数的前面<br>    baseURL:’http:jsonplaceholder.typicode.com/‘,</p><pre><code>timeout:5000</code></pre><p>})</p><p> 向外导出<br>export default  request<br>使用这种方法时： 一般我们只会在一个 js 模块创建一个axios 实例对象，并向外导出。<br>如果有多个服务器地址，那就创建多个 js模块，并在里面创建axios实例对象。<br>2.为了实现复用性，我们还可以把所有请求，都封装在API模块里，在API模块中，按需导出一个方法，这个方法调用 request.get 或 request.post 来请求一个接口，最后return 一个Promise 对象。</p><p>比如想调用接口获取用户相关信息：</p><p>在根目录新建 utils 文件夹并在里面新建 userAPI.js 文件</p><p>导入 utils 文件夹下的 request.js</p><p>import request from ‘@/utils/request.js’</p><p>export const getArticleListAPI = function(_page, _limit) {<br>  return request.get(‘/articles’, {<br>    params: {<br>      _page,<br>      _limit<br>    }<br>  })<br>}</p><p>【实例】：点击按钮发起 GET 请求并自动调用请求拦截和添加响应拦截器：</p><p>template<br>  div class=”home”<br>    button @click=”getByMineHandle”调用封装的get请求/button<br>  /div<br>/template</p><p>script<br>  导入 get 方法<br>import  { get } from ‘../utils/request’</p><p>export default {<br>  name: ‘Home’,<br>  methods:{</p><pre><code>getByMineHandle()&#123;  get(&#39;&#39;,&#123;page:3,per:2&#125;).  then(res=console.log(res))&#125;</code></pre><p>  }<br>}<br>/script</p><p>import axiox from ‘axios’</p><p>const instance =axiox.create({<br>    baseURL会在发送请求的时候拼接在url参数的前面<br>    baseURL:’http:jsonplaceholder.typicode.com/‘,<br>    timeout:5000<br>})</p><p>请求拦截<br> 所有的网络请求都会先走这个方法<br> 添加请求拦截器,所有的网络请求都会先走这个方法<br> 我们可以在它里面为请求添加一些自定义的内容 比如 token 或者在 headers 提供信息<br>instance.interceptors.request.use(function (config) {<br>     在发送请求之前做些什么<br>    console.group(‘全局请求拦截’)<br>    console.log(config)<br>    console.groupEnd()<br>    config.headers.token =’12343’<br>    return config;<br>}, function (error) {<br>     对请求错误做些什么<br>    return Promise.reject(error);<br>});</p><p> 添加响应拦截器<br>此处可以根据服务器的返回状态码做响应的处理<br>404 404 500<br>instance.interceptors.response.use(function (response) {<br>     对响应数据做点什么<br>    console.group(‘全局响应拦截’)<br>    console.log(response)<br>    console.groupEnd()<br>    return response;<br>}, function (error) {<br>     对响应错误做点什么<br>    return Promise.reject(error);<br>});</p><p> 从服务器查看获取数据<br>export function get(url,params) {<br>    return instance.get(url,{<br>        params<br>    })<br>}</p><p> 向服务器创建数据<br>export function post(url,data) {<br>    return instance.post(url,data)<br>}</p><p> 从服务器删除数据<br>export  function del(url) {<br>    return instance.delete(url)<br>}</p><p>  向服务器发送更新数据<br>export  function put(url,data) {<br>    return instance.put(url,data)<br>}</p><p>Vue-router<br>SPA 与前端路由<br>SPA (单页面网页)，所有组件的展示与切换都在这唯一的一个页面内完成。</p><p>此时，不同组件之间的切换需要依赖 前端路由(router)来实现。</p><p>什么是前端路由？</p><p>Hash 地址与组件之间的对应关系，不同的Hash 展示不同的页面。</p><p>前端路由的工作方式：</p><p>vue-router 的基本用法<br>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p><p>安装 vue-router 包</p><p>npm i <a href="mailto:&#x76;&#117;&#x65;&#45;&#x72;&#x6f;&#x75;&#116;&#x65;&#x72;&#64;&#x33;&#x2e;&#x35;&#46;&#x32;">&#x76;&#117;&#x65;&#45;&#x72;&#x6f;&#x75;&#116;&#x65;&#x72;&#64;&#x33;&#x2e;&#x35;&#46;&#x32;</a> -S<br>1<br>此时 src 源码目录下会新增一个 router 文件夹。</p><p>创建路由模块</p><p>在 src 源代码目录下，新建 router/index.js 路由模块，并初始化：</p><p>1.导入Vue和VueRouter的包import Vue from’vue’<br>import VueRouter from‘vue-router’</p><p>2.调用Vue.use（）函数，把VueRouter 安装为Vue的插件<br>Vue.use（VueRouter）</p><p>3.创建路由的实例对象<br>const router=new VueRouter（）</p><p>4.向外共享路由的实例对象<br>export default router<br>导入并挂载路由模块<br>在 src/main.js 入口文件中，导入并挂载路由模块：</p><p>import Vue from’vue’<br>import App from’./App.vue’</p><p>1.导入路由模块<br>import router from@/router’</p><p>new Vue ({<br>render:h=h（App），</p><p>2.挂载路由模块<br>router:router<br>}).$mount(‘#app’)<br>声明路由链接和占位符</p><p>在 src/App.vue 组件中，使用 vue-router 提供的 router-link 和router-view声明路由链接和占位符:</p><p>tcmplate<br>    div class=”app-container”<br>        h1App组件/h1</p><pre><code>    ！--1.定义路由链接     router-link to=&quot;/home&quot;首页/router-link    router-link to=&quot;/movie&quot;电影/router-link    router-link to=&quot;/about&quot;关于/router-link        ！--2.定义路由的占位符     router-view/router-view/div</code></pre><p>/template<br>声明路由的匹配规则<br>在 src/router/index.js 路由模块中，通过 routes 数组声明路由的匹配规则：<br>导入需要使用路由切换展示的组件</p><p>import Home from‘@/components/Home.vue’<br>import Movie from‘@/components/Movie.vue’<br>import About from‘@/components/About.vue’</p><p>2.创建路由的实例对象<br>const router=new VueRouter({<br>    在routes数组中，声明路由的匹配规则<br>    routes:[<br>        path 表示要匹配的hash地址；component表示要展示的路由组件<br>        {path:’/home’，component: Home}，<br>        {path:’/movie’，component: Movie}，<br>        {path:’/about’，component: About}<br>]<br>})<br>路由重定向<br>当访问地址 A 的时候，强制用户跳转 到地址C, 从而展示特定的组件页面。</p><p>通过路由规则的 redirect 属性，指定一个新的路由地址来实现路由的重定向。<br>下面这个应用场景，当用户访问网页 / 目录时候，跳转到首页：</p><p>const router=new VueRouter({<br>在routes数组中，声明路由的匹配规则<br>    routes:[<br>        当用户访问 / 的时候，通过 redirect 属性跳转到 /home 对应的路由规则<br>        { path: ‘/‘，redirect:’/home’ }，<br>        { path: ‘/home’，component: Home }，<br>        { path: ‘/movie’，component: Movie }，<br>        { path: ‘/about’，component: About }<br>})<br>————————————————<br>src/router/index.js 就是当前任务的路由模块  </p><ol><li>导入 Vue 和 VueRouter 的包  </li><li>调用 Vue.use() 函数, 把 VueRouter 安装为 Vue 的插件  </li><li>创建路由的实例对象<br>const router = new VueRouter({<br>routes是一个数组，作用:定义“hash 地址”与“组件”之间的对应关系<br>routes: [<br>{ path: ‘/‘, redirect: ‘/home’ },<br>{ path: ‘/Home’, component: Home },<br>{ path: ‘/Left/:id’, component: Left, props: true },  :id是动态生成id<br>{<br>  path: ‘/Right’,<br>  component: Right,<br>  redirect: ‘/Right/tab1’,<br>  children: [  <pre><code> 子路由规则   默认子路由:如果children数组中，某个路由规则的path值为空字   符串，则这条路由规则，叫做“默认子路由”  &#123; path: &#39;&#39;, component: Tab1 &#125;,  默认子路由  &#123; path: &#39;tab1&#39;, component: Tab1 &#125;,  &#123; path: &#39;tab2&#39;, component: Tab2 &#125;  </code></pre>  ]<br>}<br>]<br>}<br>)<br>vue-router提供了许多编程式导航的API,其中最常用的导航API分别是:<br>①this.$router.push(‘hash 地址’)<br>●跳转到指定 hash地址，并增加一条历史记录<br>②this.$router.replace(‘hash 地址’)<br>●跳转到指定的hash地址，并替换掉当前的历史记录<br>③this.$router.go(数值 n)<br>go(-1) 表示后退一层<br>如果后退的层数超过上限，则原地不动<br>$router.go的简化用法<br>在实际开发中，一般只会前进和后退一层页面。因此vue-router提供了如下两个便捷方法:<br>①$router.back()<br>●在历史记录中， 后退到上一一个页面<br>②$router.forward()<br>●在历史记录中， 前进到下一个页面<br>为router实例对象声明全局前置导航守卫<br>只要发生了路由的跳转，必定会触发 beforeEach 指定的function回调函数<br>router.beforeEach(function (to, from, next) {<br>to是将要访问的路由的信息对象<br>from是将要离开的路由的信息对象<br>next是一个函数，调用next() 表示放行，允许这次路由导航</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java Notes</title>
      <link href="/2022/06/26/Java-Notes/"/>
      <url>/2022/06/26/Java-Notes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java</p><p>一、标识符规则</p><p>1.标识符由英文字母大小写，0~9，_或$组成。</p><p>2.数字不可开头。</p><p>3.不能使用关键字和保留字，但可以包含关键字和保留字</p><p>4.JAVA中严格区分大小写，标识符长度无限制。</p><p>5.标识符不能含空格。</p><p> </p><p>*提示：凡是自己可以起名字的地方都叫标识符。</p><p> </p><p>二、JAVA中命名规范（行业规范）</p><p>1.包名：多单词组成，所有字母都小写，xxyyzz.</p><p>2.类名、接口名：多单词组成，所有单词首字母大写：XxYyZz.</p><p>3.变量名、方法名 ：多单词组成时，第一个单词首字母小写，第二个单词开始首字母大写：xxxYyyZzz</p><p>4.常量名：所有字母大写，多单词用下划线连接:XXX_YYY_ZZZ</p><p> </p><p>可变个数的形参:</p><p>         *  1.可变个数的形参的格式:数据类型 … 变量名</p><p>         *  2.当调用可变个数形参的方法时，传入的参数个数可以是:0个,1个,2个…….</p><p>         *  3.可变个数形参的方法与本类中方法名相同,形参不同的方法之间构成重载</p><p>         *  4.可变个数形参的方法与本类中方法名相同,形参类型也相同的数组之间不构成重载，二者不能共存</p><p>         *  5.可变个数形参在方法的形参中,必须声明在末尾,有且只能有一个</p><p> </p><p> </p><p>方法的重载(overload) loading…</p><p> * 1.定义:在同一个类中，允许存在一个以上的同名方法,只要他们的参数个数或者参数类型不同即可</p><p> *</p><p> * “两同一不同”:同一个类、相同方法名</p><p> *              参数列表不同、参数个数不同、参数类型不同</p><p> *</p><p> * 2.判断是否是重载:</p><p> *      跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系!</p><p> *</p><p> * 3.在通过对象调用方法时，如何确定某一个指定的方法:</p><p> *      方法名—&gt; 参数列表</p><p> </p><p>初始化方式一:int arr[][] = new int[4][3];</p><p>    外层元素初始化值为地址值</p><p>    内存元素初始化值与一维数组初始化情况相同</p><p>   </p><p>    初始化方式而:int arr[][] = new int[4][];</p><p>    外层元素初始化值为null</p><p>    内存元素不能调用，否则报错</p><p> </p><p>Java面向对象学习的三条主线:</p><p>//1.Java类及类的成员:属性、方法、构造器;代码块、内部类</p><p>//2.面向对象的三大特征:封装性、继承性、多态性</p><p>//3.其他关键字:this、super、static、final、abstract、interface、package、import等</p><p>// 类和对象的使用:</p><p>// 1.创建类，设计类的成员</p><p>// 2.创建类的对象</p><p>// 3.通过”对象.属性”或”对象.方法”调用对象的结构</p><p> </p><p>//属性(成员变量) vs 局部变量</p><p>//1.相同点:</p><p>//  (1)定义变量的格式:数据类型 变量名 = 变量值</p><p>//  (2)先声明，后使用</p><p>//  (3)变量都有其对应的作用域</p><p>//</p><p>//2/不同点:</p><p>//  (1)在类中声明的位置不同</p><p>//      属性:直接定义在类的一对{}内</p><p>//</p><p>//      局部变量:声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p><p>//</p><p>//  (2)关于权限修饰符的不同</p><p>//      属性:可以在声明属性时，指名其权限，使用权限修饰符。</p><p>//      常用的权限修饰符:private、public、缺省、protected   –&gt;封装性</p><p>//      目前，声明属性时，都使用缺省就可以了</p><p>//</p><p>//      局部变量:不可以使用权限修饰符</p><p>//  (3)默认初始化值的情况</p><p>//      属性:类的属性，根据其类型，都有默认初始化值。</p><p>//      整型(byte,short,int,long):0</p><p>//      浮点型(float,double):0.0</p><p>//      字符型(char):0</p><p>//      布尔类型(boolean):false</p><p>//      引用数据类型(类,接口,数组):null</p><p>//      局部变量:没有默认初始化值</p><p>//          意味着,我们在调用局部变量时,一定要是显式赋值</p><p>//          特别地：形参在调用时,我们赋值即可</p><p>//</p><p>//  (4)在内存中加载的位置</p><p>//      属性:加载到堆空间中(非static)</p><p>//</p><p>//      局部变量:加载到栈空间</p><p>关于变量的赋值</p><p>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p><p> </p><p>方法的形参的传递机制:</p><p>①值传递</p><p>1.形参:方法定义时，声明的小括号内的参数</p><p>实参:方法调用时，实际传递给形参的数据</p><p>②值传递机制</p><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</p><p>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p><p> </p><p>递归方法的使用</p><p>1.递归方法:一个方法体内调用它本身</p><p>2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p><p>递归一定要向已知反向递归，否则这种递归就变成了无穷递归，类似于死循环。</p><p> </p><p>面向对象的特征二:</p><p>一、继承性的好处:</p><p>①减少了代码的冗余:提高了代码的复用性</p><p>②便于功能的扩展</p><p>③为之后的多态性的使用提供了前提</p><p> </p><p>二、继承性的格式:class A extends B{}</p><p>A:子类、派生类、subclass<br>B:父类、超类、基类、superclass<br> <br>体现:一旦子类A继承父类B以后，子类A中就获取了父类<br>B中声明的所有的属性、方法<br>特别的:父类中声明为private的属性或方法，子类继承父类<br>以后，仍然认为获取了父类中私有的结构。<br>只是因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的扩展<br>子类和父类的关系不同于子集和集合的关系。</p><p>Extends:扩展</p><p>三、Java中关于继承性的规定:</p><p>1.一个类可以被多个子类继承<br>2.JAVA中的类的单继承性:一个类只能有一个父类<br>3.子父类是相对的概率。<br>4.子类直接继承的父类称为:直接父类;间接继承的父类称为:间接父类<br>5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p><p>四、</p><p>1.如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类<br>2.所有的JAVA类(除java.lang.Object类之外)都直接或间接的继承于java.lang.Object类<br>3.意味着，所有的java类具有java.lang.Object类声明的功能。</p><p>面向对象的特征一:封装与隐藏</p><p>一、问题的引入:</p><p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。<br>这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。<br>但是在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属<br>性声明时体现，我们只能通过方法进行限制条件的添加。<br>同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为<br>私有的。—&gt;此时，针对于属性就体现了封装性。</p><p>二、封装性的体现:</p><p>我们将类的属性xxx私有化(private)，同时，提供公共的方法(public)来获取(getXxx)和设置(set)<br>属性的值。</p><p>拓展:</p><p>封装性的体现:<br>①如上<br>②不对外暴露的私有的方法<br>③单例模式<br>……</p><p>三、封装性的体现，需要权限修饰符来配合</p><p>1.Java规定的四种权限</p><p>①private<br>②缺省<br>③protected<br>④public</p><p>2.四种权限可以用来修饰类及类的内部结构:属性、方法、构造器、内部类。</p><p>3.四种权限都可以用来修饰类的内部结构:属性、方法、构造器、内部类</p><p>修饰类的话，只能使用:缺省、public</p><p>总结：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性大小。</p><p> </p><p>属性赋值的先后顺序</p><p>①默认初始化</p><p>②显式初始化</p><p>③构造器中初始化</p><p>④通过”对象.方法” 或 “对象.属性”的方式赋值</p><p> </p><p>以上操作的先后顺序:① – ② – ③ – ④</p><p>this关键字的使用：</p><p>1.this可以用来修饰:属性、方法、构造器</p><p>2.this修饰属性和方法:this理解为当前对象或当前正在创建的对象</p><p>在类(或构造器)的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象(或正在创建的)属性或方法。但是，我们通常情况下，我们都选择省略”this.”。特殊情况下，如果方法(构造器)的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p><p>3.this调用构造器</p><p>①我们在类的构造器中，可以显式的使用”this(形参列表)”方法，调用本类中的其他构造器<br>②构造器中不能通过”this(形参列表)”调用自己<br>③如果一个类中有n个构造器，则最多有n-1个构造器中使用了”this(形参列表)”<br>④规定:”this(形参列表)”必须声明在当前构造器的首行<br>⑤构造器内部最多只能声明一个”this(形参列表)”，用来调用其他的构造器</p><p>一、package关键字的使用</p><p>1.为了更好的实现项目中类的管理，提供包的概念</p><p>2.使用package声明类或接口所属的包，声明在源文件的首行</p><p>3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、”见命知意”</p><p>4.每”.”一次，就代表一层文件目录。</p><p> </p><p>补充:同一个包下，不能命名同名的接口、类</p><p>不同的包下，可以命名同名的接口、类</p><p> </p><p>二、import关键字的作用</p><p>import导入</p><p>1.在源文件中显式的使用import结构导入指定包下的类、接口</p><p>2.声明在包的声明和类的声明之间</p><p>3.如果需要导入多个结构，则并列写出即可</p><p>4.可以使用”xxx.*“的方式表示可以导入xxx包下的所有结构</p><p>5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p><p>6.如果使用的类或接口是本包下定义的，则可以省略import结构</p><p>7.如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示</p><p>8.使用”xxx.*“方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p><p> </p><p>9.import static:导入指定类或接口中的静态结构:属性或方法(很少使用)</p><p><img src="../../_resources/image1.png" alt="image1"></p><p>方法的重写</p><p>1.重写:子类继承父类以后，可以对父类中同名同参数的方法，就行覆盖操作</p><p>2.应用:重写以后，当创建子类对象以后，通过子类对象调用父类中的同名同参数的方法</p><p>时，实际执行的是子类重写父类的方法</p><p>3.重写的规定:</p><p>方法的声明: 权限修饰符 返回值类型 方法名 throws 异常的类型(形参列表){方法体}<br>约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法<br>①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符<br>&gt;特殊情况，子类中不能重写父类中声明为private权限的方法<br>③返回值类型<br>&gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型也得是void<br>&gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类<br>&gt;父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的数据类型<br>④子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型<br>子类和父类中同名同参数的方法要么都声明为非static的，要么都声明为static的。(不是重写)</p><p>类的结构之三:构造器</p><p>一、构造器的作用:</p><p>1.创建对象<br>2.初始化对象的信息</p><p>二、说明</p><p>1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br>2.定义构造器的格式:权限修饰符 类名(形参列表){…}<br>3.一个类中定义的多个构造器，彼此构成重载<br>4.一代我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器了</p><p> </p><p>super关键字的使用</p><p>1.super理解为:父类的</p><p>2.super可以用来调用:属性、方法、构造器</p><p>3.super的使用</p><p>1.我们可以在子类的方法或构造器中，通过使用”super.属性”或<br>“super.方法”的方式，显式的调用父类中声明的属性或方法。<br>但是，通常情况下，我们习惯省略”super.”<br>2.特殊情况:当子类和父类中定义了同名的属性中，我们要在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。<br>3.特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</p><p>4.super调用构造器</p><p>1.我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定构造器<br>2.”super(形参列表)”的使用，必须声明在子类构造器的首行<br>3.我们在类的构造器中，针对于”super(形参列表)”或”this(形参列表)”只能二选一<br>4.在构造器的首行，没有显式的声明”super(形参列表)”或”this(形参列表)”则默认调用的是父类中空参的构造器:super();<br>5.在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)，调用父类的构造器</p><p>子类对象实例化的全过程</p><p>1.从结果上看:(继承性)</p><p>子类继承父类以后，就获取了父类中声明的属性或方法<br>创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</p><p> </p><p>2.从过程上来看:</p><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的<br>构造器，进而调用父类的父类的构造器，直接调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</p><p>明确:虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为你new的子类对象。</p><p>单例设计模式:</p><p>1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一一个对象实例。</p><p>2.如何实现?</p><p>饿汉式Vs懒汉式</p><p>3.区分饿汉式和懒汉式</p><p>饿汉式:坏处:对象加载时间过长<br>好处:饿汉式是线程安全的<br>懒汉式: 好处:延迟对象的创建。<br>坏处:线程不安全</p><p>面向对象特征之三:多态性</p><p>1.理解多态性:可以理解为一个事物的多种形态。<br>2.何为多态性:<br>对象的多态性:父类的引用指向子类的对象<br>3.多态的使用:虚拟方法调用<br>有了对象的多态性以后，我们在编译器，只能调用父类中声明的方法<br>总结:编译看左边；运行看右边<br>4.多态性的使用前提:①类的继承关系<br>②方法的重写<br>5.对象的多态性只适用于方法，不适用于属性(编译和运行都看左边)</p><p>main( )方法的使用说明:</p><p>1. main( )方法作为程序的入口</p><p>2. main( )方法也是一 一个普通的静态方法</p><p>3. main( )方法可以作为我们与控制台交互的方式。 (之前:使用Scanner)</p><p> </p><p>类的成员之四:代码块(或初始化块)</p><p>1.代码块的作用:用来初始化类、对象</p><p>2.代码块如果有修饰的话，只能使用static.</p><p>3.分类:静态代码块 VS 非静态代码块</p><p>4.静态代码块</p><p>&gt;内部可以有输出语句<br>&gt;随着类的加载而执行，而且只执行一-次<br>&gt;作用:初始化类的信息<br>&gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>&gt;静态代码块的执行要优先于非静态代码块的执行<br>&gt;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的属性和方法 </p><p>5.非静态代码块</p><p>&gt;内部可以有输出语句<br>&gt;随着对象的创建而执行<br>&gt;每创建一个对象， 就执行一次非静态代码块<br>&gt;作用:可以在创建对象时，对对象的属性等进行初始化<br>&gt;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>&gt;非静态代码块内可以调用静态的属性、静态的方法或非静态的属性、非静态的方法 </p><p>对属性可以赋值的位置:</p><p>①默认初始化</p><p>②显式初始化</p><p>③构造器中初始化</p><p>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p><p>⑤在代码块中赋值</p><p> </p><p>Java.lagng.Object类</p><p>1.1Object类是所有Java类的根父类</p><p>2.如果在类的声明中未使用extends关键字指明其父类，则默认</p><p>父类为java.lang.Object类</p><p>3.Object类中的功能(属性、方法)就具有通用性</p><p>4.Object类只声明了一个空参的构造器</p><p> </p><p>instanceof关键字的使用</p><p>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</p><p>使用情景:为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先</p><p>进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不就行向下转型</p><p> </p><p>如果a instanceof A返回true，则a instanceof B也返回true</p><p>其中，类B是类A的父类</p><p>二、equals( )方法的使用:</p><p>1.是一个方法，而非运算符</p><p>2.只能适用于引用数据类型</p><p>3. Object类中equals( )的定义:</p><p>Public boolean equals(Object obj)<br>{<br>Return(this == obj)<br>}<br>说明:Object类中定义的equals()和==的作用是相同的:<br>比较两个对象的地址值是否相同，即两个引用是否指向相同的变量</p><p>4.像String、Data、File、包装类等都重写了Object类中的equals()方法，重写以后比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p><p>5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的实体内容是否相同。那么，我们就需要对Object类中的equals()进行重写</p><p>1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，</p><p>系统将不可能把父类里的方法转移到子类中:编译看左边，运行看右边</p><p>2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，</p><p>这个实例变量依然不可能覆盖父类中定义的实例变量:编译运行都看左边</p><p> </p><p>static关键字的使用</p><p>1.static:静态的</p><p>2.static可以用来修饰:属性、方法、代码块、内部类</p><p>3.用static修饰属性:静态变量</p><p>1.属性按是否用static修饰分为:静态属性、非静态属性(实例变量)<br>实例变量:我们创建了类的多个对象，每个对象都拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。<br> <br>静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，其他对象调用此静态变量时是修改过了的。<br>2.static修饰属性的其他说明:<br>①静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用<br>②静态变量的加载早于对象的创建<br>③由于类只会加载一次，则静态变量在内存中也只会存在一份:存在方法区的静态域中<br>④ 类变量 实例变量<br>类 yes no<br>对象 yes yes<br>3.静态属性举例:</p><p>4.用static修饰方法:静态方法</p><p>①随着类的加载而加载，可以通过”类.静态方法”的方式进行调用。<br>② 静态方法 非静态方法<br>类 yes no<br>对象 yes yes<br>③静态方法中，只能调用静态的方法或属性<br>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</p><p>5.static注意点</p><p>1.在静态的方法内，不能使用this和super关键字<br>2.关于静态属性和静态方法的使用，大家都从生命周期的角度去理解 </p><p>6.开发中，如何确定一个属性是否要声明为static的？</p><p>&gt;属性是可以被多个对象所共享的，不会随着对象的不同而不同的</p><p>开发中，如何确定一个方法是否要声明为static的？</p><p>&gt;操作静态属性的方法，通常设置为static的<br>&gt;工具类中的方法，习惯上声明为static的。比如:Math、Arrays</p><p>final :最终的</p><p>1. final可以用来修饰的结构:类、方法、变量</p><p>2. final用来修饰一一个类:此类不能被其他类所继承。</p><p>比如: String类、System类、StringBuffer类</p><p>3. final用来修饰方法:表明此方法不可以被重写</p><p>比如: object类中getClass();</p><p>4. final用来修饰变量:此时的”变量”就称为是一 个常量</p><p>4.1 final修饰属性:<br>可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化<br>4.2 final修饰局部变量:<br>尤其是使用final修饰形参时，表明此形参是一一个常量。当我们调用此方法时，给常量形参赋一一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 </p><p>static final 用来修饰属性:全局常量</p><p> </p><p>abstract关键字的使用</p><p>1. abstract:抽象的</p><p>2. abstract可以用来修饰的结构:类、方法</p><p>3. abstract修饰类:抽象类</p><p>&gt;此类不能实例化<br>&gt;抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程)<br>&gt;开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p><p>4. abstract修饰方法:抽象方法</p><p>&gt;抽象方法只有方法的声明， 没有方法体<br>&gt;包含抽象方法的类，-定是一一个抽象类。反之，抽象类中可以没有抽象方法的。<br>&gt;若子类重写了 父类中的所有的抽象方法后，此子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类， 需要使用abstract修饰</p><p>abstract使用上的注意点:</p><p>1.abstract不能用来修饰:属性、构造器等结构<br>2.abstract不能用来修饰私有方法、静态方法、final方法、final类</p><p>接口的使用</p><p>1.接口使用interface来定义</p><p>2.Java中，接口和类是并列的两个结构</p><p>3.如何定义接口:定义接口中的成员</p><p>3.1 JDK7及以前:只能定义全局常量和抽象方法<br>&gt;全局常量: public static final的. 但是书写时，可以省略不写<br>&gt;抽象方法: public abstract的<br>3.2 JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)</p><p>4.接口中不能定义构造器的!意味着接口不可以实例化</p><p>5. Java开发中，接口通过让类去实现( implements )的方式来使用.</p><p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化<br>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p><p>6. Java类可以实现多个接口 — &gt;弥补了Java单继承性的局限性</p><p>格式: class AA extends BB implements CC,DD,EE</p><p>7.接口与接口之间可以继承，而且可以多继承</p><p>8.接口的具体使用，体现了多态性</p><p>9.接口，实际上可以看做是一种规范</p><p> </p><p>接口的使用</p><p>1.接口使用上也满足多态性</p><p>2.接口，实际上就是定义了一种规范</p><p>3.开发中，体会面向接口编程!</p><p> </p><p>JKD8中接口的新特性</p><p>知识点1:接口中定义的静态方法，只能通过接口来调用。</p><p>知识点2:通过实现类的对象，可以调用接口中的默认方法。</p><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p><p>知识点3:如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。– &gt;类优先原则</p><p>知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错。– &gt;接口冲突。这就需要我们必须在实现类中重写此方法</p><p>知识点5:在子类(或实现类)的方法中调用父类、接口中被重写的方法 接口名.super.方法名()</p><p>类的内部成员之五:内部类</p><p>1. Java中 允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p><p>2.内部类的分类:成员内部类(静态、非静态) Vs 局部内部类(方法内、代码块内、构造器内)</p><p>3.成员内部类:</p><p>一方面，作为外部类的成员:<br>&gt;调用外部类的结构<br>&gt;可以被static修饰<br>&gt;可以被4种不同的权限修饰<br>另一方面，作为一个类:<br>&gt;类内可以定义属性、方法、构造器等<br>&gt;可以被final修饰， 表示此类不能被继承。言外之意，不使用final,就可以被继承<br>&gt;可以被abstract修饰</p><p> </p><p>一、异常体系结构</p><p>java. lang. Throwable</p><p>—–java. lang. Error:-般不编写针对性的代码进行处理。<br>—–java. lang. Exception:可以进行异常的处理<br>—–j编译时异常( checked)<br>—–jIoException<br>—–FileNot FoundException<br>—–ClassNotFoundException<br>——运行时异常(unchecked )<br>—– NullPointerException<br>—– ArrayIndexOutOfBounds Exception<br>—–ClassCastException<br>—– NumberF ormatException<br>—– InputMi smatchException<br>—– ArithmeticException</p><p> </p><p>说明:</p><p>1. finally是 可选的。</p><p>2.使用try将可能出现异常代码包装起来，在执行过程中，-旦出现异常，就会生成-一个对应异常类</p><p>的对象，根据此对的类型，去catch中进行匹配。</p><p>3.一旦try中的异常对象匹配到某一 个catch时，就进入catch中进行异常的处理。一旦处理完成，</p><p>就跳出当前的try-catch结构(在没有写finally的情况)。继续执行其后的代码</p><p>4. catch中的异常类型如果没有子父类关系， 则谁声明在上，谁声明在下无所谓。</p><p>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p><p>5.常用的异常对象处理的方式:①String getMessage( ) ②printStackTrace()</p><p>6.在try结构中声明的变量，再出了try结构以后，就不能再被调用</p><p>7.try-catch-finally结构可以嵌套</p><p> </p><p>体会:使用try-catch- finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p><p>体会2:开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，针对于编译时异常，我们说一定要考虑异常的处理。</p><p> </p><p>try-catch-finally中finally的使用:</p><p>1. finally是可选的</p><p>2. finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p><p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能 自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p><p>异常处理的方式二: throws +异常类型</p><p>1. “throws +异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。</p><p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象， 此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行!</p><p>2.体会: try-catch-finally :真正的将异常给处理掉了。</p><p>throws的方式只是将异常抛给了方法的调用者。并没有真正将 异常处理掉。</p><p>3.开发中如何选择使用try-catch-finally还是使用throws?</p><p>1如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws,意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。<br> <br>2执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throw的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p><p> </p><p>方法重写的规则之一:</p><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 </p><p>如何自定义异常类?</p><p>1.继承于现有的异常结构: RuntimeException 、Exception<br>2.提供全局常量: serialVersionUID<br>3.提供重载的构造器</p><p> </p><p>一、异常的处理:抓抛模型</p><p>过程一: “抛”:程序在正常执行的过程中，-旦出现异常，就会在异常代码处生成一一个对应异常类的对象。并将此对象抛出。<br>一旦抛出对象以后，其后的代码就不再执行。</p><p>关于异常对象的产生:①系统自动生成的异常对象</p><p>②手动的生成一一个异常对象，并抛出(throw)</p><p>过程二: “抓”: 可以理解为异常的处理方式:①try-catch-finally ② throws</p><p> </p><p>测试Thread中的常用方法:</p><p>1. start(): 启动当前线程;调用当前线程的run()</p><p>2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p><p>3. currentThread():静态方法， 返回执行当前代码的线程</p><p>4. getName():获取当前线程的名字</p><p>5. setName(): 设置当前线程的名字</p><p>6. yield():释放当前cpu 的执行权</p><p>7. join(): 在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p><p>8. stop():已过时。当执行此方法时，强制结束当前线程。</p><p>9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。 在指定的millitime毫秒时间内，当前线程是阻塞状态。</p><p>10. isAlive(): 判断当前线程是否存活</p><p>线程的优先级:</p><p>1.MAX_ PRIORITY: 10</p><p>MIN_PRIORITY: 1</p><p>NORM_ PRIORITY: 5 –&gt;默认 优先级</p><p>2.如何获取和设置当前线程的优先级:</p><p>getPriority():获取线程的优先级</p><p>setpriority(int p): 设置线程的优先级</p><p> </p><p>说明:高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</p><p>多线程的创建，方式一:继承于Thread类</p><p>* 1.创建一个继承于Thread类的子类</p><p>* 2.重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</p><p>* 3.创建Thread类的子类的对象</p><p>* 4.通过此对象调用start()</p><p>创建多线程的方式二:实现Runnable接口</p><p>1.创建-一个实现了Runnable接口的类</p><p>2. 实现类去实现Runnable中的抽象方法: run()</p><p>3.创建实现类的对象</p><p>4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p><p>5.通过Thread类的对象调用start()</p><p> </p><p>比较创建线程的两种方式。</p><p>开发中:优先选择:实现Runnable接口的方式</p><p>原因: 1.实现的方式没有类的单继承性的局限性</p><p>2.实现的方式更适合来处理多个线程有共享数据的情况。</p><p>联系: public class Thread impl ements Runnable</p><p>相同点:两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p><p>例子:创建三个窗口卖票，总粟数为100张使用实现Runnable接口的方式</p><p>1.问题:卖粟过程中，出现了重票、错粟–&gt;出现了线程的安全问题</p><p>2.问题出现的原因:当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票</p><p>3.如何解决:当-一个线程a在操作ticket的时候， 其他线程不能参与进来。 直到线程a操作完ticket时，线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变</p><p>4.在Java中， 我们通过同步机制，来解决线程的安全问题。</p><p>方式一:同步代码块</p><p>synchronized(同步监视器){</p><p>// 需要被同步的代码</p><p>}</p><p>5.同步的方式，解决了线程的安全问题。—好处</p><p>操作同步代码时，只能有一 个线程参与，其他线程等待。相当于是-一个单线程的过程，效率低。</p><p>说明: 1. 操作共享数据的代码，即为需要被同步的代码 –&gt;不能包含代码多了，也不能包含代码少</p><p>2.共享数据:多个线程共同操作的变量。比如: ticket 就是共享数据。<br>3.同步监视器，俗称:锁。任何一个类的对象，都可以充当锁。<br> <br>补充:在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 </p><p>要求:多个线程必须要共用同一把锁。</p><p> </p><p>方式二:同步方法</p><p>如果操作共享数据的代码完整的声明在一一个方法中，我们不妨将此方法声明同步的。</p><p>关于同步方法的总结:</p><p>1.同步方法仍然涉及到同步监视器，只是不需要我 们显式的声明。</p><p>2.非静态的同步方法，同步监视器是: this</p><p>静态的同步方法，同步监视器是:当前类本身</p><p> </p><p>演示线程的死锁问题</p><p>1.死锁的理解:不同的线程分别占用对方需要的同步资源不放弃，</p><p>都在等待对方放弃自己需要的同步资源，就形成J线程的死锁</p><p>2.说明:</p><p>1)出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继缕</p><p>2)我们使用同步时，要避免出现死锁。</p><p>解决线程安全问题的方式三: Lock锁— JDK5.日新增</p><p>1.面试题: synchronized 与Lock的异同?</p><p>相同:二者都可以解决线程安全问题<br>不同: synchronized机 制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步(lock())，同时结束同步也需要手动的实现(unlock() )</p><p>线程通信的例子:使用两个线程打印1-100。 线程1,线程2交替打印</p><p>涉及到的三个方法:</p><p>wait():- -旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</p><p>notify():-旦执行此方法，就会唤醒被wait的-一个线程。如果有多个线程被wait,就唤醒优先级高的线程</p><p>notifyAll():-旦执行此方法，就会唤醒所有被wait的线程。</p><p> </p><p>说明:</p><p>1.wait(), notify()， notifyAll()三个方法必须使用在同步代码块或同步方法中。</p><p>2.wait(), notify(), notifyALl()三个方法的调用者必须是同步代码块或同步方法中的同步监视器</p><p>否则，会出现ILlegaLMoni torStateException异常</p><p>3. wait(), notify(), notifyALL()三个方法是定义在java. lang. object类中。</p><p>面试题: sLeep() 和wait()的异同?</p><p>1.相同点:一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p>2.不同点:</p><p>1)两个方法声明的位置不同: Thread类中声明sleep() ，object类中声明wait()</p><p>2)调用的要求不同: sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p><p>3)关于是否释放同步监视器:如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，wait()会释放同步监视器</p><p> </p><p><strong>应用线程池的好处：</strong></p><ul><li><p>  提高响应速度（减少了创建新线程的时间）</p></li><li><p>  降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理<br>  corePoolSize：核心池的大小<br>  maximumPoolSize：最大线程数<br>  keepAliveTime：线程没任务时最多保持多长时间后会终止</p></li></ul><p>创建线程的方式三:实现Callable接口。— JDK 5.0新增</p><ul><li><p>  创建一个实现Callable的实现类</p></li><li><p>  实现call方法，将此线程需要执行的操作声明在call()中</p></li><li><p>  创建Callable接口实现类的对象</p></li><li><p>  将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</p></li><li><p>  将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</p></li><li><p>  获取Callable中call方法的返回值</p></li></ul><p> </p><p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大?</p><p>1. call()可以有返回值的。<br>2. call()可以抛出异常，被外面的操作捕获，获取异常的信息<br>3. Callable是支持泛型的</p><p> </p><p> </p><p>String:字符串，使用一对””引起来表示。</p><p>1. String声明为final的，不可被继承</p><p>2. String实现TSerializable接口:表示字符串是支持序列化的。</p><p>实现了Comparable接口:表示String 可以比较大小</p><p>3. String内部定义了final char[] value用于存储字符串数据</p><p>4. String:代表不可变的字符序列。简称:不可变性。</p><p>体现:</p><p>1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值<br>3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值</p><p>5.通过字面量的方式(区别于new)给-一个字符串赋值，此时的字符串值声明在字符串常量池中。</p><p>6.字符串常量池中是不会存储相同内容的字符串的。</p><p> </p><p>String、StringBuffer、 StringBuilder三者的异同?</p><p>String:不可变的字符序列;底层使用char[]存储</p><p>StringBuffer:可变的字符序列;线程安全的，效率低;底层使用char[]存储</p><p>StringBuilder:可变的字符序列; jdk5. 日新增的，线程不安全的，效率高;底层使用char[]存储</p><p>对比String、StringBuffer、 StringBuilder三者的效率:</p><p>从高到低排列: StringBuilder &gt; StringBuffer &gt; String</p><p>java. util.Date类</p><p>—-java. sql. Date类</p><p>1.两个构造器的使用</p><p>&gt;构造器- -: Date():创建一个对应当前时间的Date对象<br>&gt;构造器二:创建指定毫秒数的Date对象</p><p>2.两个方法的使用</p><p>&gt;toString():显示当前的年、月、日、时、分、秒<br>&gt;getTime():获取当前Date对象对应的毫秒数。(时间戳)</p><p>3. java. sqL. Date对应着数据库中的日期类型的变量</p><p>&gt;如何实例化<br>&gt;如何将java. util. Date对象转换为java. sql. Date对象</p><p>一、说明: Java中的对象，正常情况下，只能进行比较: ==或!=。不能使用&gt;或&lt;的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实?使用两个接口中的任何一个: Comparable 或Comparator</p><p>Comparable,接口的使用举例:</p><p>1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式</p><p>2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</p><p>3.重写compareTo(obj)的规则:</p><p>如果当前对象this.大于形参对象obj,则返回正整数,<br>如果当前对象this小于形参对象obj,则返回负整数,<br>如果当前对象this等于形参对象obj,则返回零。</p><p>4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</p><p>在compareTo(obj)方法中指明如何排序</p><p>Comparator接口的使用:定制排序</p><p>1.背景:</p><p>当元素的类型没有实现java. Lang. Comparable接口而又不方便修改代码,或者实现了java. lang<br>. Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序</p><p> </p><p>2.重写compare(Object o1, Object o2)方法，比较o1和o2的大小:</p><p>如果方法返回正整数，则表示01大于o2;<br>如果返回e，表示相等;<br>返回负整数，表示o1小于o2。 </p><p>一、说明: Java中的对象，正常情况下，只能进行比较: ==或!=。不能使用&gt;或&lt;的</p><p>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。<br>如何实现?使用两个接口中的任何一个: Comparable 或Comparator </p><p>二、Comparable 接口与Comparator的使用的对比:</p><p>Comparable接口的方式一旦指定，保证Comparable 接口实现类的对象在任何位置都可以比较大小<br>Comparator.接口属于临时性的比较。</p><p>一、枚举类的使用</p><p>1.枚举类的理解:类的对象只有有限个，确定的。我们称此类为枚举类<br>2.当需要定义一-组常量时，强烈建议使用枚举类<br>3.如果枚举类中只有一一个对象，则可以作为单例模式的实现方式。</p><p>二、如何定义枚举类</p><p>方式一: jdk5.0之前， 自定义枚举类<br>方式二: jdk5.0， 可以使用enum关键字定义枚举类</p><p>三、Enum类中的常用方法: .</p><p>values()方法:返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。<br>value0f(String str):可以把一 -个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象<br>tostring():返回当前枚举类对象常量的名称</p><p>四、使用enum关键字定义的枚举类实现接口的情况</p><p>情况一:实现接口,在enum类中实现抽象方法<br>情况二:让枚举类的对象分别实现接口中的抽象方法</p><p> </p><p>一、注解的使用<br>① jdk 5.0 新增的功能<br>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。<br>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的 name = value 对中。<br>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android 中注占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。<br>⑤ 框架 = 注解 + 反射机制 + 设计模式<br> <br>二、注解的使用示例<br>示例一：生成文档相关的注解</p><ul><li><p>  @author 标明开发该类模块的作者，多个作者之间使用，分割 @version 标明该类模块的版本；</p></li><li><p>  @see 参考转向，也就是相关主题；</p></li><li><p>  @since 从哪个版本开始增加的；</p></li><li><p>  @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是 void 就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用 throws 显式抛出的异常就不能写；</p></li><li><p>  其中 @param 、 @return 和 @exception 这三个标记都是只用于方法的。</p></li><li><p>  @param 的格式要求：@param 形参名形参类型形参说明；</p></li><li><p>  @return 的格式要求：@return 返回值类型返回值说明；</p></li><li><p>  @exception 的格式要求：@exception 异常类型异常说明；</p></li><li><p>  @param 和 @exception 可以并列多个；</p></li></ul><p>示例二：在编译时进行格式检查(JDK内置的个基本注解)<br>@Override: 限定重写父类方法, 该注解只能用于方法；<br>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；<br>@SuppressWarnings: 抑制编译器警告；<br>三、如何自定义注解</p><ul><li><p>  注解声明为：@interface</p></li><li><p>  内部定义成员，通常使用value表示</p></li><li><p>  可以指定成员的默认值，使用default定义</p></li><li><p>  如果自定义注解没成员，表明是一个标识作用。</p></li></ul><!-- --><ul><li><p>  如果注解有成员，在使用注解时，需要指明成员的值。</p></li><li><p>  自定义注解必须配上注解的信息处理流程(使用反射)才意义。</p></li></ul><p> </p><p>|—-Collection接口：单列集合，用来存储一个一个的对象</p><p>|—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组</p><p>|—-ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</p><p>|—-LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</p><p>|—-Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</p><p>|—-Set接口：存储无序的、不可重复的数据 –&gt;数学概念上的“集合”</p><p>|—-HashSet：作为Set接口主要实现类;线程不安全;可以存null值</p><p>                |—-LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</p><p>|—-TreeSet：可以按照添加对象的指定属性，进行排序。</p><p> </p><p> </p><p>|—-Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x)</p><p>|—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</p><p>|—-LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</p><p>原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</p><p>对于频繁的遍历操作，此类执行效率高于HashMap。</p><p>|—-TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</p><p>底层使用红黑树</p><p>|—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</p><p>|—-Properties:常用来处理配置文件。key和value都是String类型</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C Notes</title>
      <link href="/2020/06/26/C-Notes/"/>
      <url>/2020/06/26/C-Notes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="C语言知识点汇总"><a href="#C语言知识点汇总" class="headerlink" title="*C语言知识点汇总"></a>*C语言知识点汇总</h3><h4 id="总体上："><a href="#总体上：" class="headerlink" title="总体上："></a>总体上：</h4><ol><li>程序结构（3种）：<strong>顺序结构</strong>、<strong>选择结构（分支结构）</strong>、<strong>循环结构</strong>。</li><li>读取程序从main()开始，然后自上而下读取。一个程序<strong>有且只有一个main函数</strong>。</li><li>计算机的数据在电脑中保存是以<strong>二进制的形式</strong>，<strong>数据存放的位置就是地址</strong>。</li><li>位（bit）是指0或1.byte是指字节，<strong>一个字节 = 8个位</strong>。</li></ol><h4 id="概念常考："><a href="#概念常考：" class="headerlink" title="概念常考："></a>概念常考：</h4><ol><li><strong>编译预处理</strong>不是C语言的一部分，<strong>不占</strong>运行时间，<strong>不要</strong>加分号。C语言编译的程序称为<strong>源程序</strong>，它以<strong>ASCII数值</strong>存放在文本文件中。</li><li>define PI 3.1415926；<strong>写法错误</strong>，<strong>一定不要出现分号</strong>。</li><li>每个C语言程序中<strong>有且只有一个main函数</strong></li><li>在函数中<strong>不可以再定义函数</strong>。</li><li>算法：可以<strong>没有输入</strong>，但是<strong>一定要有输出</strong></li><li>break可用于<strong>循环结构</strong>和<strong>switch语句</strong>，<strong>if语句中不能用break语句</strong>。</li><li><strong>逗号运算符</strong>的级别<strong>最低</strong>，<strong>赋值</strong>的级别<strong>倒数第二</strong>。</li></ol><h3 id="C语言基础知识"><a href="#C语言基础知识" class="headerlink" title="C语言基础知识"></a>C语言基础知识</h3><h5 id="第一节-对C语言的基础知识"><a href="#第一节-对C语言的基础知识" class="headerlink" title="第一节 对C语言的基础知识"></a>第一节 对C语言的基础知识</h5><ol><li>C语言编写的程序称为<strong>源程序</strong>，又称为<strong>编译单位</strong>。</li><li>C语言<strong>书写格式自由</strong>，每行可以写多条语句，一条语句也可以写多行。</li><li>一个C语言程序<strong>有且只有一个主函数</strong>，是程序运行的<strong>起点</strong>。</li></ol><h5 id="第二节-熟悉-vc"><a href="#第二节-熟悉-vc" class="headerlink" title="第二节 熟悉 vc++"></a>第二节 熟悉 vc++</h5><ol><li>VC是软件，用来运行C语言程序。</li><li>每个C语言程序写完后，都是<span style="color:red;"><strong>先编译，后链接，最后运行</strong></span>。<span style="color:red;"><strong>（.c-&gt;.obj-&gt;.exe）</strong></span>这个过程中注意**.c和.obj<strong>文件是</strong>无法运行<strong>。只有</strong>exe<strong>文件</strong>才可以运行**.</li></ol><h5 id="第三节-标识符"><a href="#第三节-标识符" class="headerlink" title="第三节 标识符"></a>第三节 标识符</h5><ol><li><span style="color:red;"><strong>标识符（必考内容）：由字母、数字、下划线组成，且开头字母必须为字母或者下划线</strong></span></li><li><span style="color:red;"><strong>标识符分为关键字、预定义标识符、用户标识符。</strong></span><ol><li><span style="color:red;"><strong>关键字：不可以作为用户标识符。main、define、scanf、printf都不是关键字。迷惑性的地方是C语言区分大小写，故而If是可以作为用户标识符的。</strong></span></li><li>预定义标识符：<strong>预定义标识符可以作为用户标识符的</strong>。</li></ol></li></ol><h5 id="第四节-进制的转换"><a href="#第四节-进制的转换" class="headerlink" title="第四节 进制的转换"></a>第四节 进制的转换</h5><h5 id="第五节-整数与实数"><a href="#第五节-整数与实数" class="headerlink" title="第五节 整数与实数"></a>第五节 整数与实数</h5><ol><li><p>C语言只有八进制、十进制、十六进制，没有二进制。但是运行时候，所有的进制都要转换成二进制进行处理。</p><ol><li>C语言中八进制规定要以0开头。018的数值非法，八进制数为0-7。逢八进一。</li><li>C语言中十六进制规定以0x开头。</li></ol></li><li><p>小数的合法写法：C语言小数点两边有一个是零的话，可以省略。</p><ol><li><strong>1.0在C语言中可写成1.</strong></li><li><strong>0.1在C语言中可写成.1</strong></li></ol></li><li><p>实型数据的合法形式：</p><ol><li>2.333e-1就是合法的，且数据是2.333*10^-1。</li><li><strong><span style="color:red;">考试口诀：e前e后必有数，e后必为整数。</span></strong></li></ol></li><li><p>整形一般为4个字节，字符型是1个字节，双精度一般是8个字节。</p></li></ol><h5 id="第六、第七节-算术表达式与赋值表达式：核心：表达式一定要有数值"><a href="#第六、第七节-算术表达式与赋值表达式：核心：表达式一定要有数值" class="headerlink" title="第六、第七节 算术表达式与赋值表达式：核心：表达式一定要有数值"></a>第六、第七节 算术表达式与赋值表达式：<span style="color:red;">核心：表达式一定要有数值</span></h5><ol><li><p>算数表达式：+、-、*、/、%</p><p>注意事项：</p><ol><li>“/”两边如果为整形，结果也为整形：3/2的结果为1。</li><li>“/”如果有一边为小数，那么结果也为小数：3/2.0的结果就是0.5。</li><li>“%”符号为取余数，与“/”区分开。%符号两边要求为整数。</li></ol></li><li><p>赋值表达式：表达式数值是最左边的数值，<strong>a=b=5；该表达式的数值为5，常量不可以赋值</strong></p><ol><li>int x=y=10:错误，定义时，不可以连续赋值。</li><li>int x,y;x=y=10;正确，定义后，可以连续赋值。</li><li>赋值左边只能是一个变量。</li><li>int x=7.7;正确，x的值为7。</li><li>float x=7;正确，x的值为7.0。</li></ol></li><li><p>复合的赋值表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">a*=<span class="number">2</span>+<span class="number">3</span>;<span class="comment">//运行完成后，a的值为10；根据运算符优先级*=在+后面故而a=a*(2+3)</span></span><br></pre></td></tr></table></figure></li><li><p>自增表达式、自减表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">5</span>;</span><br><span class="line">a++;<span class="comment">//a++表达式值为5，a的值为6</span></span><br><span class="line">++a;<span class="comment">//++a表达式值为7，a的值为7</span></span><br><span class="line">b--;<span class="comment">//b--表达式值为5，b的值为4</span></span><br><span class="line">--b;<span class="comment">//--b表达式值为3，b的值为3</span></span><br><span class="line"><span class="comment">//运行机制：++a是先对变量进行自增，再为表达式赋值。a++先对表达式进行赋值，在对变量进行自增。</span></span><br><span class="line"><span class="comment">//++在前先加后用，++在后先用再加。</span></span><br></pre></td></tr></table></figure></li><li><p>逗号表达式：</p><p>优先级最低。表达式的数值逗号最右边的那个表达式的数值（2，3，4）表达式的值为4。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//赋值表达式，z的值为4</span></span><br><span class="line">z = <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;<span class="comment">//这个时候，z的值为2</span></span><br></pre></td></tr></table></figure><p>补充：</p><ol><li><p>空语句不可以随意执行，会导致逻辑错误。</p></li><li><p><strong>注释不是C语言，不占用运行时间，没有分号，不可以嵌套</strong>！</p></li><li><p>强制类型转换：一定是(int)a而不是int(a)，注意类型上一定要有括号</p><p>注意(int)(a+b)和(int)a+b的差距，前者是将a+b的值转型，后者是把a的值转型后再加b</p></li><li><p>三种取整丢小数的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1.6</span>;</span><br><span class="line">(<span class="type">int</span>)a;</span><br><span class="line"><span class="number">1</span>/<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="第八节-字符"><a href="#第八节-字符" class="headerlink" title="第八节 字符"></a>第八节 字符</h5><ol><li><p>字符数据的合法形式：</p><p>‘I’是字符占一个字节，”1“是字符串占两个字节（含一个结束字符）</p><p><strong>‘0’</strong>的ASCII数值表示为<strong>48</strong>，<strong>‘a’</strong>的ASCII的数值是<strong>97</strong>，<strong>‘A’</strong>的ASCII数值是<strong>65</strong>。</p><p>一般考试单字符错误的形式：”1“、‘65’</p><p>字符是可以进行算术运算的，‘0’-0=48</p><p>大写字母和小写字母转换的方式：‘A’+32=‘a’ 大小写转换+32</p><p><strong>数字&lt;大写字母&lt;小写字母</strong></p><p><strong>48       65      97</strong></p></li><li><p>转义字符（<strong>一般转义字符、八进制转义字符、十六进制转义字符</strong>）：</p><p>一般转义字符：\0、\n、\‘、\“、\\</p><p>八进制转义字符：’\141‘合法，前导0不能写</p><p>十六进制转义字符：’\x6d’合法，前导0不能写，并且x为小写。</p></li><li><p>字符型和整数是近亲：两者具有很大的相似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">65</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a);<span class="comment">//A</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);<span class="comment">//65</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="基础函数（printf、scanf）"><a href="#基础函数（printf、scanf）" class="headerlink" title="基础函数（printf、scanf）"></a>基础函数（printf、scanf）</h3><h5 id="第一节、第二节-数据输出"><a href="#第一节、第二节-数据输出" class="headerlink" title="第一节、第二节 数据输出"></a>第一节、第二节 数据输出</h5><ol><li><p>使用printf和scanf函数时，要在最前面加#include&lt;stdio.h&gt;</p></li><li><p>printf可以只有一个参数，也可以有两个参数。</p></li><li><p>printf(“第一部分”,第二部分);把第二部分的变量、表达式、常量以第一部分的形式展现出来。</p></li><li><p>```c<br>printf(“a=%d,b=%d”,12,34);//a=12,b=34<br>printf(“a=%d,\nb=%d”,12,34);//a=12,</p><pre><code>                        //b=34</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```c</span><br><span class="line">   int x = 017;</span><br><span class="line">   printf(&quot;%d&quot;,x);//15</span><br><span class="line">   printf(&quot;%o&quot;,x);//17</span><br><span class="line">   printf(&quot;%#o&quot;,x);//017</span><br><span class="line">   printf(&quot;%x&quot;,x);//f</span><br><span class="line">   printf(&quot;%#x&quot;,x);//0xf</span><br></pre></td></tr></table></figure></li><li><p>```c<br>int x = 12,y=34;<br>char z = ‘a’;<br>printf(“%d”,x,y);//12<br>printf(“%c”,z);//a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. | 格式说明 | 表示内容                        | 格式说明 | 表示内容       |</span><br><span class="line">   | -------- | ------------------------------- | -------- | -------------- |</span><br><span class="line">   | %d       | 整型 int                        | %c       | 字符char       |</span><br><span class="line">   | %ld      | 长整型 long int                 | %s       | 字符串         |</span><br><span class="line">   | %f       | 浮点型 单精度float              | %o       | 八进制         |</span><br><span class="line">   | %lf      | 双精度double                    | %#o      | 带前导的八进制 |</span><br><span class="line">   | %%       | 输出百分号                      | %x       | 十六进制       |</span><br><span class="line">   | %5d/%-5d | 少于指定5位时左部空格，负号右补 | %#x      | 带前导的八进制 |</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   printf(&quot;%2d&quot;,123);//123</span><br><span class="line">   printf(&quot;%5d&quot;,123);//  123</span><br><span class="line">   printf(&quot;%10f&quot;,1.25);//1.250000</span><br><span class="line">   printf(&quot;%5.3f&quot;,1.25);//1.250</span><br><span class="line">   printf(&quot;%3.1f&quot;,1.25);//1.3</span><br></pre></td></tr></table></figure></li></ol><h5 id="第三节-数据输入"><a href="#第三节-数据输入" class="headerlink" title="第三节 数据输入"></a>第三节 数据输入</h5><ol><li><p>例1：scanf(“a=%d,b=%d”,&amp;a,&amp;b)</p><p>一定要记住在终端上输入数据时要以第一部分的格式输入，其格式要求一摸一样</p><p>例1输入：a=12,b=34才能将12、34正确赋值给a、b</p></li><li><p>```c<br>scanf(“%d,%d”,x,y);//写法错误，scanf第二部分为地址<br>scanf(“%d,%d”,&amp;x,&amp;y);//写法正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **&lt;span style=&quot;color:red&quot;&gt;指针在scanf中的考察：&lt;/span&gt;**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   int x = 2;int *p = &amp;x;</span><br><span class="line">   scanf(&quot;%d&quot;,x);//出错</span><br><span class="line">   scanf(&quot;%d&quot;,p);//正确</span><br><span class="line">   scanf(&quot;%d&quot;,&amp;p);//出错</span><br><span class="line">   scanf(&quot;%d&quot;,*p);//出错</span><br></pre></td></tr></table></figure></li><li><p><strong><span style="color:red">指定输入的长度(考试重点)</span></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//终端输入1234567</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%2d%4d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<span class="comment">//x=12 y=3456 z=7</span></span><br><span class="line"><span class="comment">//终端输入1 234567 12中包含一个空格，所以x=1</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%2d%4d%d&quot;</span>,&amp;x,&amp;y,&amp;z);<span class="comment">//x=1 y=2345 z=67</span></span><br><span class="line"><span class="comment">//终端输入1234567</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%2d%*2d%ld&quot;</span>,&amp;x,&amp;y); <span class="comment">//*2d 表示忽略2个数，x=12 y=567</span></span><br></pre></td></tr></table></figure></li><li><p><strong><span style="color:red">字符和整型是近亲</span></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">97</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);<span class="comment">//97</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,x);<span class="comment">//a</span></span><br></pre></td></tr></table></figure></li><li><p><strong><span style="color:red">输入时候字符和整数的区别</span></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入1，注意这个是整数1</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;x);<span class="comment">//输入1，注意这个是字符‘1’ ascii为整数48</span></span><br></pre></td></tr></table></figure><p><strong><span style="color:red">补充</span></strong></p><ol><li><p>scanf函数的格式考察：<strong>注意该函数的第二部分是&amp;a为地址，不是a内容；指针本身就是一个地址加上&amp;为内容；与变量区别</strong></p></li><li><p>putchar，getchar函数考察</p><p>char a = getchar()是没有参数的，从键盘中得到第一个输入的字符赋值给变量a</p><p>putchar(‘y’)将字符y输出到屏幕中</p></li><li><p>如何实现将x、y的值交换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=y,y=z;<span class="comment">//这种写法错误</span></span><br><span class="line"><span class="comment">//而是先将x，y的值交换需要使用中间变量；</span></span><br><span class="line">t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t;</span><br></pre></td></tr></table></figure></li><li><p>如何实现保留三位小数，第四位四舍五入的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y=(<span class="type">int</span>)(x*<span class="number">1000</span>+<span class="number">0.5</span>)/<span class="number">1000.0</span>;<span class="comment">//这个保留两位小数，第三位四舍五入</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="表达式-选择结构"><a href="#表达式-选择结构" class="headerlink" title="表达式+选择结构"></a>表达式+选择结构</h3><h5 id="特别注意事项："><a href="#特别注意事项：" class="headerlink" title="特别注意事项："></a>特别注意事项：</h5><p>​    <strong><span style="color:red">C语言中使用非0表逻辑真，用0表逻辑假。</span></strong></p><p>​    <strong><span style="color:red">C语言有构造类型，没有逻辑类型</span></strong></p><p>​    <strong><span style="color:red">关系运算符号，注意&lt;=的写法，==和=的区别！！！！</span></strong></p><p>​    <strong><span style="color:red">if只管后面一个语句，要管多个，需要使用大括号！！！！</span></strong></p><h5 id="1-关系表达式"><a href="#1-关系表达式" class="headerlink" title="1. 关系表达式"></a>1. 关系表达式</h5><ol><li><p>表达式的数值只能是1(表示为真)或0（表示为假）</p><p>如9&gt;8为真，所以该表达式值为1</p><p>如7&lt;6为假，所以该表达式值为0</p></li><li><p>考试常错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>,y = <span class="number">0</span>,z = <span class="number">2</span>;</span><br><span class="line">x&lt;y&lt;z<span class="comment">//1&lt;0&lt;2,1&lt;0为假则为0，再用1&lt;0表达式的值0再去跟2比较，0&lt;2为真则x&lt;y&lt;z表达式的值为1</span></span><br></pre></td></tr></table></figure></li><li><p>等号和赋值的区别！一定要记住“=”就是赋值，“==”就是等号，</p></li></ol><h5 id="2-逻辑表达式"><a href="#2-逻辑表达式" class="headerlink" title="2. 逻辑表达式"></a>2. 逻辑表达式</h5><p>核心：表达式的数值只能为1或0</p><ol><li><p>共有&amp;&amp; || ！ 三种逻辑运算符号</p></li><li><p>!&gt;&amp;&amp;&gt;|| 优先顺序</p></li><li><p>注意短路现象，考试易考</p></li><li><p>表示x小于10大于0的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>&lt;x)&amp;&amp;(x&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-if语句"><a href="#3-if语句" class="headerlink" title="3.if语句"></a>3.if语句</h5><ol><li><p>else是与最接近的if且没有else的语句匹配。</p></li><li><p>交换的程序写法：t=x;x=y;y=z;</p></li><li><p>```<br>if(a&lt;b) t=a;a=b;b=t;//如果a&lt;b则赋值t<br>if(a&lt;b){t=a;a=b;b=t};//如果a&lt;b则将ab值调换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">   //单独的if语句：</span><br><span class="line">   if(a&lt;b) t=a;</span><br><span class="line">   //标准的if语句：</span><br><span class="line">   if(a&lt;b) min=a;</span><br><span class="line">   else min = b;</span><br><span class="line">   //嵌套的if语句</span><br><span class="line">   if(a&lt;b)</span><br><span class="line">   if(b&gt;c) printf(&quot;ok&quot;);</span><br><span class="line">   //多选一的if语句</span><br><span class="line">   if(a==t) printf(&quot;a&quot;);</span><br><span class="line">   else if(b==t) printf(&quot;b&quot;);</span><br><span class="line">   else if(c==t) printf(&quot;c&quot;);</span><br><span class="line">   else printf(&quot;d&quot;)</span><br></pre></td></tr></table></figure></li></ol><p>经典例题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>,b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!a) b++;<span class="comment">//false</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">if</span>(a) b+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> b+=<span class="number">3</span>;</span><br><span class="line"><span class="comment">//b=0</span></span><br><span class="line"><span class="comment">//正确格式是：</span></span><br><span class="line"><span class="keyword">if</span>(!a)</span><br><span class="line">    b++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(a)</span><br><span class="line">        b+=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        b+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><h5 id="4-条件表达式"><a href="#4-条件表达式" class="headerlink" title="4.条件表达式"></a>4.条件表达式</h5><p><strong>表达式1？表达式2：表达式3</strong></p><p><strong>口诀：真前假后</strong></p><ol><li><p>注意当表达式1的数值为非0时，才采用表达式2的数值为整个运算结果，当表达式1的数值为0时，就用表达式3的数值作为整个的结果</p></li><li><p>```c<br>int a = 1,b = 2,c = 3,d = 4,e = 5;<br>k=a&gt;b?c:d&gt;e?d:e;//k=5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 5.switch语句</span><br><span class="line"></span><br><span class="line">1. 执行的流程！！！！</span><br><span class="line"></span><br><span class="line">2. 注意有break和没有break的差别，有break则直接跳出switch语句。</span><br><span class="line"></span><br><span class="line">3. switch只可以和break一起用，不可以和continue使用</span><br><span class="line"></span><br><span class="line">4. ```c</span><br><span class="line">   switch(x)&#123;//x是整型常量、字符型常量、枚举型常量</span><br><span class="line">   case 1:...;//case 后面跟常量不可以时变量</span><br><span class="line">   case 2:...;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h5 id="1-三种循环结构"><a href="#1-三种循环结构" class="headerlink" title="1.三种循环结构"></a>1.三种循环结构</h5><ol><li>for();while();do-while();三种</li><li>for循环当中必须是两个分号。</li><li>写程序的时候一定要注意，循环一定要有结束的条件，否则成了死循环</li><li>do-while();循环的最后一个while();的分号不能丢。do-while循环是至少执行一次循环</li></ol><h5 id="2-break和continue的差别"><a href="#2-break和continue的差别" class="headerlink" title="2.break和continue的差别"></a>2.break和continue的差别</h5><p>记忆方法：</p><p>break：打破，break直接跳出整个循环</p><p>continue：继续，结束本次循环，进行下一次循环。跳到循环开始。</p><h5 id="3-嵌套循环"><a href="#3-嵌套循环" class="headerlink" title="3.嵌套循环"></a>3.嵌套循环</h5><p>循环中包含循环，需要一层一层的计算。</p><h5 id="4-while-c-getchar-’-n’-和while-c-getchar-’-n’-的差别"><a href="#4-while-c-getchar-’-n’-和while-c-getchar-’-n’-的差别" class="headerlink" title="4.while((c=getchar())!=’\n’)和while(c=getchar()!=’\n’)的差别"></a>4.while((c=getchar())!=’\n’)和while(c=getchar()!=’\n’)的差别</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如a=3!=2和（a=3）!=2的差别（!=的级别高于=所以先计算3!=2）第一个a的数值得到的是1；第二个数值得到的是3</span></span><br><span class="line"><span class="comment">//考试注意点：看清括号的重要性</span></span><br></pre></td></tr></table></figure><h5 id="5-每行输出五个的写法："><a href="#5-每行输出五个的写法：" class="headerlink" title="5.每行输出五个的写法："></a>5.每行输出五个的写法：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-如何整除一个数："><a href="#6-如何整除一个数：" class="headerlink" title="6.如何整除一个数："></a>6.如何整除一个数：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i%<span class="number">5</span>==<span class="number">0</span>;<span class="comment">//表整除5</span></span><br><span class="line">i%<span class="number">2</span>==<span class="number">0</span>;<span class="comment">//表整除2</span></span><br></pre></td></tr></table></figure><h5 id="7-输入123，输出321逆序输出数据"><a href="#7-输入123，输出321逆序输出数据" class="headerlink" title="7.输入123，输出321逆序输出数据"></a>7.输入123，输出321逆序输出数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a%<span class="number">10</span>);</span><br><span class="line">    a/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-for只管后面一个语句"><a href="#8-for只管后面一个语句" class="headerlink" title="8.for只管后面一个语句"></a>8.for只管后面一个语句</h5><h5 id="9-多次出现的考题！！！！"><a href="#9-多次出现的考题！！！！" class="headerlink" title="9.多次出现的考题！！！！"></a>9.多次出现的考题！！！！</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(--k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);<span class="comment">//结果为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k--);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,k);<span class="comment">//结果为1</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p>函数：是具有一定功能的程序块，是C语言的基本组成单位</p></li><li><p>函数不可以嵌套定义、但可以嵌套调用</p></li><li><p>函数名缺省返回值类型，默认为int。</p></li><li><p><strong>C语言由函数组成，但有且只有一个主函数！主函数是程序运行的开始!</strong></p></li><li><p><strong>如何判断一个数是否为质数？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iszhishu</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> s,i;</span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;a/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>)&#123;</span><br><span class="line">            s=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不是质数&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是质数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何求阶层：n!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数的参数可以是常量、变量、表达式，甚至可以是函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="comment">//函数名缺省返回值类型，默认为int</span></span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;<span class="comment">//函数名缺省返回值类型，默认为int</span></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = add(add(<span class="number">7</span>,<span class="number">8</span>),<span class="number">9</span>);<span class="comment">//sum = (7+8)+9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><span style="color:red">参数之间的传递！！！(重点)</span></strong></p><p>实参和形参之间<strong>传数值</strong>和<strong>传地址</strong>的<strong>差别</strong>！！！！</p><p>传数值：形参的变化<strong>不会导致</strong>实参的变化</p><p>传地址：形参的变化<strong>可能导致</strong>实参的变化</p></li><li><p>函数声明：</p><p>一定要有：函数名，函数的返回值类型，函数的参数类型</p><p>不一定有：形参的名称</p></li><li><p><strong><span style="color:red">库函数的掌握</span></strong></p><p>常考库函数，要求对库函数的功能进行了解：</p><table><thead><tr><th>库函数</th><th>头文件</th><th>功能</th></tr></thead><tbody><tr><td>abs()</td><td>stdlib.h</td><td>整数运算函数 求绝对值</td></tr><tr><td>sqrt()</td><td>math.h</td><td>平方根函数</td></tr><tr><td>fabs()</td><td>math.h</td><td>浮点运算函数 求绝对值</td></tr><tr><td>pow()</td><td>math.h</td><td>幂函数</td></tr><tr><td>sin()</td><td>math.h</td><td>正弦函数</td></tr></tbody></table></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>数组：数组存放的类型是一致的，多个数组元素的地址是连续的</strong></p><ol><li><p>一维数组的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//非法，其数组包含的元素个数多于规定的元素个数</span></span><br></pre></td></tr></table></figure></li><li><p>一维数组的定义；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考点：定义数组时数组个数不是变量，一定是常量</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>+<span class="number">2</span>];<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1</span>/<span class="number">2</span>+<span class="number">4</span>];<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;<span class="type">int</span> a[x];<span class="comment">//非法</span></span><br><span class="line">define P <span class="number">5</span></span><br><span class="line"><span class="type">int</span> a [P];<span class="comment">//合法</span></span><br></pre></td></tr></table></figure></li><li><p>二维数组的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;<span class="comment">//非法</span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;<span class="comment">//非法</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><ol><li><p>数组的重要概念</p><p>对a[10]一维数组的讨论</p><ol><li>a表示一个数组名，是第一个元素的地址，也就是说元素a[0]的地址(等价于&amp;a)</li><li>a是地址常量，所以只要出现a++,或者说a=a+2赋值都是错误的。</li><li>a是一维数组名，所以它是列指针，也就是说a+1是跳一列</li></ol><p>对a[3] [3]二维数组的讨论</p><ol><li>a表示一个数组名，是第一个元素的地址，也就是说是元素a[0] [0]的地址</li><li>a是地址常量，所以只要出现a++,或者说a=a+2赋值都是错误的。</li><li>a是二维数组名，所以它是行指针，也就是说a+1是跳一行</li><li>a[0]、a[1]、a[2]也都是地址常量，不可以对它进行赋值操作，同时他们都是列指针，a[0]+1、a[1]+1、a[2]+1都是跳一列</li><li>注意a和a[0]、a[1]、a[2]是不同的，它们的基类型不同，前者是一行元素，后三者是一列元素</li></ol></li><li><p>二维数组的技巧：</p><p>例a[3] [3] = {1,2,3,4,5,6,7,8,9}</p><ol><li><p>将二维数组用表格展示</p><table><thead><tr><th></th><th>第一列</th><th>第二列</th><th>第三列</th></tr></thead><tbody><tr><td>a[0]第一行-&gt;</td><td>1</td><td>2</td><td>3</td></tr><tr><td>a[1]第二行-&gt;</td><td>4</td><td>5</td><td>6</td></tr><tr><td>a[2]第三行-&gt;</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></li></ol></li><li><p><strong>两种数组长度</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//数组长度为3，字符串长度不定，sizeof(a)为3</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;<span class="comment">//数组长度为3，字符串长度为5，sizeof(a)为5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>数组中存放数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">b[a[<span class="number">3</span>]]++;<span class="comment">//该写法b[4]++,本身是0，运行完，b[4]为1了。</span></span><br></pre></td></tr></table></figure></li><li><p>字符串的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[<span class="number">10</span>]=&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;;<span class="comment">//正解</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>]=<span class="string">&quot;abcdefgh&quot;</span>;<span class="comment">//正解</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>&#125;;<span class="comment">//正解</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abcdefgh&quot;</span>;<span class="comment">//正解</span></span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p=<span class="string">&quot;abcdefgh&quot;</span>;<span class="comment">//正解</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line">ch=<span class="string">&quot;abcdefgh&quot;</span>;<span class="comment">//错解，数组名不可以赋值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p=&#123;<span class="string">&quot;abcdefgh&quot;</span>&#125;;<span class="comment">//错解，不可以出现大括号</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>#define PI  3.14  //  pi 的宏定义</p><p>#define R 654 //半径 r的宏定义</p><p>#define V PI * R * R * R *4 / 3  // 宏定义的嵌套  算体积</p><p>#define Max(x,y) ((x)&gt;(y) ? (x) : (y))  //带参数的宏定义</p><p>// 注意 最好参数带括号  举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE x x*x</span></span><br><span class="line">main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">//输入5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的平方根是%d&quot;</span>,x,SQUARE(x)); <span class="comment">//  结果为   x * x=25</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的平方根是%d&quot;</span>,x+<span class="number">1</span>,SQUARE(x+<span class="number">1</span>)); <span class="comment">//  结果为   x+1*x+1=11 使用宏定义时注意优先级的问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h5><p>如果宏太长，一个单行容纳不下时，则使用宏延续运算符(\)。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br></pre></td></tr></table></figure><h5 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h5><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);<span class="comment">//Carole and Debra: We love you!</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="标记粘贴运算符"><a href="#标记粘贴运算符" class="headerlink" title="标记粘贴运算符"></a>标记粘贴运算符</h5><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tokenpaster(n) printf (<span class="string">&quot;token&quot;</span> #n <span class="string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);<span class="comment">//token34 = 40</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>typedef关键字是用来为类型新定义一个名称</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">140</span>];</span><br><span class="line">&#125;Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    date d;</span><br><span class="line">    Book books;</span><br><span class="line">    d.year = <span class="number">2020</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(books.title,<span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s,%d&quot;</span>,books.title,d.year);<span class="comment">//西游记,2020</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>  //创建结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line"><span class="type">float</span> price;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> date;</span><br><span class="line"><span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">&#125;book;  <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//struct Book book; // 定义局部变量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book</span>=</span>&#123;  <span class="comment">// 初始化一个结构体变量</span></span><br><span class="line">      <span class="string">&quot;&lt;&lt;c语音从入门到入土“，</span></span><br><span class="line"><span class="string">      &quot;</span>小甲鱼<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      458.8,</span></span><br><span class="line"><span class="string">      20171111,</span></span><br><span class="line"><span class="string">      &quot;</span>清华大学出版社<span class="string">&quot;</span></span><br><span class="line"><span class="string">  &#125;;  </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    book.title=&quot;</span>c语音从入门到入土<span class="string">&quot;; // 赋值</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    printf(&quot;</span>%s<span class="string">&quot;,book.title); // 使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>注意：结构体 内的属性 按4个字节对齐  定义 book={char s int a char b } sizeof（book）为12 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> date;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">120</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date</span>;</span></span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Book *<span class="title function_">input</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">struct</span> Book *<span class="title function_">input</span><span class="params">(<span class="keyword">struct</span> Book *b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入添加的书名:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入该书的作者:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b-&gt;author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入该书的单价:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;b-&gt;price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入该书的发行日期:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,&amp;b-&gt;date.year,&amp;b-&gt;date.month,&amp;b-&gt;date.date);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入该书的出版社:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b-&gt;publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Book</span><span class="params">(<span class="keyword">struct</span> Book *b)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b-&gt;title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b-&gt;author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,b-&gt;price);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\n&quot;</span>,b-&gt;date.year,b-&gt;date.month,b-&gt;date.date);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b-&gt;publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">b1</span>[10];</span></span><br><span class="line">    input(b1);</span><br><span class="line">    Book(b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;Memory size occupied by data : %d\n&quot;</span>, <span class="keyword">sizeof</span>(data));<span class="comment">//Memory size occupied by data : 20</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共用体占用的内存应足够存储共用体中最大的成员。</p><p>其次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);<span class="comment">//data.i : 1917853763</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);<span class="comment">//data.f : 4122360580327794860452759994368.000000</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);<span class="comment">//data.str : C Programming</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原因是最后使用的共用体成员会覆盖掉之前的共用体成员，也就是之前使用的共用体成员会产生损坏。说明了在同一时间内只能使用一个变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span>        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.i : %d\n&quot;</span>, data.i);<span class="comment">//data.i : 10</span></span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.f : %f\n&quot;</span>, data.f);<span class="comment">//data.f : 220.500000</span></span><br><span class="line">   </span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">&quot;C Programming&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;data.str : %s\n&quot;</span>, data.str);<span class="comment">//data.str : C Programming</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里能完整输出主要原因是在同一时间内只使用了一个共用体成员</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h5 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;<span class="comment">//一个整型的指针</span></span><br><span class="line"><span class="type">double</span> *dp;<span class="comment">//一个双精度浮点型的指针</span></span><br><span class="line"><span class="type">float</span> *fp;<span class="comment">//一个单精度浮点型的指针</span></span><br><span class="line"><span class="type">char</span> *cp;<span class="comment">//一个字符型的指针</span></span><br></pre></td></tr></table></figure><h5 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h5><p>使用指针时会频繁进行以下几个操作：<strong>定义一个指针变量</strong>、<strong>把变量地址赋值给指针</strong>、<strong>访问指针变量中可用地址的值</strong>。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="type">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var 变量的地址: %p\n&quot;</span>, &amp;var  );<span class="comment">//var 变量的地址:0x7ffeeef168d8</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ip 变量存储的地址: %p\n&quot;</span>, ip );<span class="comment">//ip 变量存储的地址: 0x7ffeeef168d8</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip );<span class="comment">//*ip 变量的值: 20</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NULL指针"><a href="#NULL指针" class="headerlink" title="NULL指针"></a>NULL指针</h5><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;ptr 的地址是 %p\n&quot;</span>, ptr  );<span class="comment">//ptr 的地址是0x0</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="指针的算数运算："><a href="#指针的算数运算：" class="headerlink" title="指针的算数运算："></a>指针的算数运算：</h5><p>概括为：</p><ol><li>指针的每一次递增，它其实会指向下一个元素的存储单元</li><li>指针的每一次递减，他其实会指向上一个元素的存储单元</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向的数据类型长度，例如int就是4个字节</li></ol><h6 id="递增指针"><a href="#递增指针" class="headerlink" title="递增指针"></a>递增指针</h6><p>变量指针可以递增，而数组不可以递增，数组可以看作是一个指针常量。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">3</span>;<span class="comment">//全局变量</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  var[] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line">   <span class="type">int</span>  i, *ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 指针中的数组地址 */</span></span><br><span class="line">   ptr = var;<span class="comment">//ptr指向var数组的第一个地址</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">   &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;第%d个存储地址：var[%d] = %p\n&quot;</span>, (i+<span class="number">1</span>),i, ptr );</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;第%d个存储值：var[%d] = %d\n&quot;</span>, (i+<span class="number">1</span>), i, *ptr );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* 指向下一个位置 */</span></span><br><span class="line">      ptr++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印如下</span></span><br><span class="line"><span class="comment">//第1个存储地址：var[0] = e4a298cc</span></span><br><span class="line"><span class="comment">//第1个存储值：var[0] = 10</span></span><br><span class="line"><span class="comment">//第2个存储地址：var[1] = e4a298d0</span></span><br><span class="line"><span class="comment">//第2个存储值：var[1] = 100</span></span><br><span class="line"><span class="comment">//第3个存储地址：var[2] = e4a298d4</span></span><br><span class="line"><span class="comment">//第4个存储值：var[2] = 200</span></span><br></pre></td></tr></table></figure><h5 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span>  V;</span><br><span class="line">   <span class="type">int</span>  *Pt1;</span><br><span class="line">   <span class="type">int</span>  **Pt2;</span><br><span class="line"> </span><br><span class="line">   V = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 获取 V 的地址 */</span></span><br><span class="line">   Pt1 = &amp;V;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用运算符 &amp; 获取 Pt1 的地址 */</span></span><br><span class="line">   Pt2 = &amp;Pt1;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 pptr 获取值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;var = %d\n&quot;</span>, V );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Pt1 = %p\n&quot;</span>, Pt1 );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;*Pt1 = %d\n&quot;</span>, *Pt1 );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pt2 = %p\n&quot;</span>, Pt2 );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;**Pt2 = %d\n&quot;</span>, **Pt2);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印如下：</span></span><br><span class="line"><span class="comment">//var = 100</span></span><br><span class="line"><span class="comment">//Pt1 = 0x7ffee2d5e8d8</span></span><br><span class="line"><span class="comment">//*Pt1 = 100</span></span><br><span class="line"><span class="comment">//Pt2 = 0x7ffee2d5e8d0</span></span><br><span class="line"><span class="comment">//**Pt2 = 100</span></span><br></pre></td></tr></table></figure><h5 id="传递指针给函数"><a href="#传递指针给函数" class="headerlink" title="传递指针给函数"></a>传递指针给函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   getSeconds( &amp;sec );</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 输出实际值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Number of seconds: %ld\n&quot;</span>, sec );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getSeconds</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *par)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* 获取当前的秒数 */</span></span><br><span class="line">   *par = time( <span class="literal">NULL</span> );</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从函数返回指针"><a href="#从函数返回指针" class="headerlink" title="从函数返回指针"></a>从函数返回指针</h5><p>下面的函数，它会生成 10 个随机数，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们，具体如下：</p><p>C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p><p>```c<br>#include &lt;stdio.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;stdlib.h&gt; </p><p>/* 要生成和返回随机数的函数 */<br>int * getRandom( )<br>{<br>   static int  r[10];<br>   int i;</p><p>   /* 设置种子 */<br>   srand( (unsigned)time( NULL ) );<br>   for ( i = 0; i &lt; 10; ++i)<br>   {<br>      r[i] = rand();<br>      printf(“%d\n”, r[i] );<br>   }</p><p>   return r;<br>}</p><p>/* 要调用上面定义函数的主函数 <em>/<br>int main ()<br>{<br>   /</em> 一个指向整数的指针 */<br>   int *p;<br>   int i;</p><p>   p = getRandom();<br>   for ( i = 0; i &lt; 10; i++ )<br>   {<br>       printf(“*(p + [%d]) : %d\n”, i, *(p + i) );<br>   }</p><p>   return 0;<br>}<br>//打印如下：<br>//1523198053<br>//1187214107<br>//1108300978<br>//430494959<br>//1421301276<br>//930971084<br>//123250484<br>//106932140<br>//1604461820<br>//149169022<br>//<em>(p + [0]) : 1523198053<br>//</em>(p + [1]) : 1187214107<br>//<em>(p + [2]) : 1108300978<br>//</em>(p + [3]) : 430494959<br>//<em>(p + [4]) : 1421301276<br>//</em>(p + [5]) : 930971084<br>//<em>(p + [6]) : 123250484<br>//</em>(p + [8]) : 1604461820<br>//*(p + [9]) : 149169022</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
